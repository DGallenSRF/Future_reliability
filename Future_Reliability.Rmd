---
title: "I 494 Reliability"
output:
  html_document:
    df_print: paged
---

```{r setup,message=FALSE, include=FALSE}
knitr::opts_knit$set(root.dir = 'C:/Users/dgallen/Desktop/Projects/Future_reliability')

##below are a list of packages required to run the markdown file
library(tidyverse)
library(lubridate)
library(gridExtra)
library(reshape2)
library(zoo)
library(rgdal)
library(mgcv)
library(data.table)
library(plotly)
library(broom)
library(nlstools)
library(purrr)
library(flextable)
library(officer)
library(readxl)
library(DBI)
library(odbc)
library(ggthemes)
library(leaflet)
library(Hmisc)
dir()
```


## LOAD DATA 


```{r read data from SQL, include = FALSE}

drv <- DBI::dbConnect(odbc(),
                      driver = 'SQL Server',
                      server = 'VS-SQL02',
                      database = 'Traffic',
                      uid = 'TrafficUser',
                      pwd = 'dubliNmusTang',
                      port = 5432)

Data_494 <- DBI::dbReadTable(drv, 'Existing494')

# adjusted VMT after SRF edits to TICAS pull
VMT_Data_494 <- select(DBI::dbReadTable(drv, 'ExistingVMT494'), DateTime = cut_ceiling, Segment, VMT_total_SRF = VMT_total)

Data_494 <- merge(Data_494,VMT_Data_494)
```


```{r fix column names, include = FALSE}

##Turn SQL time (UTC) to US/Central

Data_494$DateTime <- as.POSIXct(as.POSIXlt(Data_494$DateTime, tz = 'America/Chicago'))
```

```{r initial load of segment data in database, include=FALSE}

# path <- 'H:/Projects/11000/11155/TraffStudy/Reliability/'
# Seg <- read_xls(paste(path,
#                       'Segment_494_TableToExcel.xls',
#                       sep = ''))
# 
# Seg <- Seg %>%
#   select(everything(),Nearest_Station = `Nearest Station`) %>%
#   select(Direction, Segment_No, Segment_Location, LAT, LONG, INT, Measure_Round, Nearest_Station, Length) %>%
#   mutate(Lanes = 4,
#          Future = '-',
#          Exist_Demand = '-')
# 
# DBI::dbWriteTable(drv, 'Segments_494', Seg, overwrite = TRUE)
```

### Add variables to the existing dataset 

15 minute volume takes the VMT for each time bin and divides by the length of the segment. Unit: Vehicles per mile.
Speed is the segment length divided by the travel time ( * 60). Unit: Miles per hour.
Hourly_Flow is the 15 minute volume multipled by 4 and divided by the number of lanes. Unit: Vehicles per hour.
Density is the Hourly Flow divided by speed. Unit: Vehicles per hour.

We also create a variable that measures the delay type experienced by the segment. Weather (snow) events and crashes were tracked for the time period. If the segment experiences a weather event and a crash, weather will be the controlling delay type.


```{r add_variables, include=FALSE}

Seg <- DBI::dbReadTable(drv, 'Segments_494')

Segments_494 <-  Seg %>% filter(!is.na(Length)) %>%
  select(Segment = Segment_No, Lanes, Length) %>%
  arrange(Segment)

# Segments_494[Segments_494$Segment == 3,"Lanes"] <- 3
# Segments_494[Segments_494$Segment == 6,"Lanes"] <- 3

Data_494 <- merge(Data_494, Segments_494, by = 'Segment')

Rel <- Data_494 %>% 
  mutate(Vol_15_min  = VMT_total/Length,
         Speed       = Length/TT_mean*60,
         Hourly_Flow_per_lane = Vol_15_min*4/Lanes,
         Dens_lane        = Hourly_Flow_per_lane/Speed,
         Hour        = as.factor(format(DateTime,format = '%H')),
         Month       = as.factor(format(DateTime,format = '%m')),
         WeekDay     = as.factor(weekdays(DateTime)),
         DateTimeSec = as.numeric(DateTime)) %>%
  filter(!is.na(DateTime))
```


```{r add_conditionals, include = FALSE}

test_list <- list()
result <- vector()
for (i in 1:length(Rel$weather)){
  n <- 8
  n <- ifelse(i < n, i, n)
  test_list[i] <- list(Rel$weather[i:(i-n)])
  result[i] <- ifelse(unlist(any(test_list[[i]] == 1)),1,0)
}
rm(test_list)
head(result)

Rel$weather2hour <- result

test_list <- list()
result <- vector()
for (i in 1:length(Rel$Crash)){
  n <- 4
  n <- ifelse(i < n, i, n)
  test_list[i] <- list(Rel$Crash[i:(i-n)])
  result[i] <- ifelse(unlist(any(test_list[[i]] == 1)),1,0)
}
rm(test_list)
head(result)

Rel$Crash2hour <- result

Rel <- Rel %>% 
  mutate(Delay_type  = (ifelse(weather2hour == 1, 
                               'Weather',
                               ifelse(Crash2hour == 1, 
                                      'Crash',
                                      'None'))),
         is_Delay       = ifelse(Delay_type == 'None', 
                                 'No_Delay',
                                 'Delay'),
         Index = seq(1,length(Speed),1),
         Is_weekday = ifelse(WeekDay %in% c('Monday','Tuesday','Wednesday','Thursday','Friday'),1,0))

```



Check the dataset for outliers by plottling all of the travel time obsevations for each segment. 

```{r filter for outlier, echo=FALSE}

ggplot(Rel,aes(x = as.factor(Segment),y = TT_mean)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.5) +
  annotate('rect',xmin=8.2,xmax = 9.5,ymin = 35,ymax = 79,alpha = 0.2)+
  annotate('text',x=7.9,y=57, label = '3 outlier travel times experienced/n during crash incident',hjust = 1)

```

We see three significant outliers in Segment 9. Upon inspection of the dataset, these travel times were observed during a crash incident. 

```{r Seg 9 outliers, include=FALSE}

Rel %>%
  filter(Segment == 9) %>%
  arrange(desc(TT_mean)) %>%
  print()

```


```{r bin data, echo=FALSE, messages = FALSE}


bins <- c(seq(floor(min(Rel$Dens_lane)),50,2),60,70,80,90,100,125,150,200,300,400,480)


#1S
# bins <- c(seq(floor(min(Rel_2014$Dens)),50,2),
#           60,70,80,100,125,150,round(max(Rel_2014$Dens)+1,0))

Rel$cut <- cut(Rel$Dens_lane,bins,echo.lowest = TRUE)
Rel$Density_bin_Lane <- as.numeric(stringi::stri_match_last_regex(Rel$cut,'[0-9]+')) 

Rel_spare <- Rel

```


### Percentile Bin and Free Flow

We will break down the dataset into each delay type and then further into percentiles. 

```{r percentiles, echo=FALSE}

p <- c(.05,.1,0.25,0.5,0.75,0.9,.95)

# p <- c(.05,.1, 0.2, .3, .4, .5, .6, .7, .8, .9, .95)

# p <- seq(0.05,0.95,0.05)
```


The percentiles choosen are `r p`.

For each quantile a travel time quantile is calculated. We also want to calculate a Free Floew Speed for each quantile. 

```{r create binned dataset, include=FALSE}

Rel_bin <- Rel %>%
  mutate(Density_bin_Lane = as.numeric(stringi::stri_match_last_regex(cut,'[0-9]+'))) %>%
  group_by(Segment,Delay_type,Density_bin_Lane) %>%
  # group_by(Delay_type,Density_bin) %>%
  summarise(quantiles = list(sprintf("%1.0f%%", p*100)),
            TT_quantile = list(quantile(TT_mean,p))) %>%
  unnest() %>%
  merge(.,Segments_494, by = 'Segment') %>%
  mutate(Speed = Length/TT_quantile*60,
         Flow_Hour_Lane = Speed * Density_bin_Lane,
         quantiles = as.factor(quantiles)) %>%
  as.data.frame()

Rel_FF <- Rel_bin %>%
  # group_by(Delay_type,quantiles) %>%
  group_by(Segment,Delay_type,quantiles) %>%
  summarise(FF_quantile = round(quantile(Flow_Hour_Lane/Density_bin_Lane,.95, na.rm = TRUE),0))


Rel_bin <- merge(Rel_bin,Rel_FF) %>%
  mutate(Index_bin = as.integer((seq(1,length(FF_quantile),1))),
         TTI = TT_quantile/(Length/FF_quantile * 60))

# Rel_bin$quantiles <- factor(Rel_bin$quantiles,levels(Rel_bin$quantiles)[c(5,1:4,6:11)])
                            
head(Rel_bin)
```

The Free Flow speeds were calcuated using the 95th percentile speeds. 


## MAP


```{r map, echo=FALSE, fig.height=2}


m <- leaflet() %>%
  addTiles() %>%
  addLabelOnlyMarkers(lng = subset(Seg, Segment_Location == 'START')$LONG,
                      lat = subset(Seg, Segment_Location == 'START')$LAT, 
                      label = paste(as.character(subset(Seg, Segment_Location == 'START')$Segment_No),
                                    substring(subset(Seg, Segment_Location == 'START')$Segment_Location,1,1)),
                      labelOptions = labelOptions(noHide = T, direction = 'top')) %>%
    addLabelOnlyMarkers(lng = subset(Seg, Segment_Location == 'END')$LONG,
                      lat = subset(Seg, Segment_Location == 'END')$LAT, 
                      label = paste(as.character(subset(Seg, Segment_Location == 'END')$Segment_No),
                                    substring(subset(Seg, Segment_Location == 'END')$Segment_Location,1,1)),
                      labelOptions = labelOptions(noHide = T, direction = 'bottom')) 

m
```

## FREE FLOW PLOTS {.tabset .tabset-fade}

```{r free flow plot, include = FALSE}
free_flow_plot <- function(seg, legend = ''){
  ff <- ggplot()+
    geom_point(data = data.frame(Rel_bin[Rel_bin$Segment == seg,]),
               aes(x=Density_bin_Lane,y=Flow_Hour_Lane, color=quantiles))+
    geom_abline(data = data.frame(Rel_FF[Rel_FF$Segment == 1,]),
                aes(slope = FF_quantile, intercept = 0, 
                    linetype = 'dashed', color = quantiles))+
    facet_grid(~ Delay_type, scales = 'free')+
    theme(legend.position=legend)+
    ggtitle(paste('Segment:',seg))
  ggplotly(ff)
}
```




### Segment 1

```{r free flow plot seg1, fig.width = 11,echo = FALSE, message = FALSE}

free_flow_plot(1, 'none')
```



## DENSITY vs TT {.tabset .tabset-fade}

A look at the Density vs travel time plots. A generic smooting function has been added. 

```{r dens vs tt plot, include=FALSE}

dens_tti_plot <- function(seg,legend = '', sp = 1){
  tt <- ggplot()+
    geom_point(data=Rel_bin[Rel_bin$Segment == seg,],
               aes(x= Density_bin_Lane,y = TT_quantile, color= quantiles))+
    geom_smooth(data=Rel_bin[Rel_bin$Segment == seg,],
                aes(x= Density_bin_Lane,y = TT_quantile, color= quantiles),span=sp,se=F)+
    facet_grid(~Delay_type, scales = 'free')+
    theme(legend.position=legend)+
    ggtitle(paste('Segment:',seg))
  ggplotly(tt)
}
```

```{r save pre filter data, include=FALSE}
Rel_bin_preFilter <- Rel_bin
# Rel_bin <- Rel_bin_preFilter
```



### Segment 1

```{r seg1 filter}
Rel_bin <- Rel_bin %>%
  filter(!(Segment == 1 & Density_bin_Lane > 199)) %>%
  filter(!(Segment == 1 & Delay_type == 'None' & Density_bin_Lane > 100)) %>%
  filter(!(Segment == 1 & Delay_type == 'Weather' & Density_bin_Lane > 89)) %>%
  filter(!(Segment == 1 & Delay_type == 'Crash' & Density_bin_Lane > 45))

```

```{r Density vs TT seg1, fig.width = 11, echo = FALSE, message = FALSE}
dens_tti_plot(2,'',1)
```

## DENSITY vs FLOW {.tabset .tabset-fade}

Below are the Flow vs Density plots for each condition. 

```{r load density flow manual table, include = FALSE}
getwd()
dens_flow_tab <- read.csv('./congestion density flow table.csv')
dens_flow_tab <- dcast(dens_flow_tab, Segment + quantiles + Delay_type + Axis ~ Measure, value.var = 'Value') %>%
  select(Density_cong_Lane = Density, Flow_cong_Hour_Lane = Flow, everything())
head(dens_flow_tab)
```

```{r dens_flow_plot, include=FALSE}

dens_flow_plot <- function(seg,legend='', bin = NA){
  
  dens_flow_data <- filter(dens_flow_tab, Segment == seg)
  
  flow_dens <-
  if(is.na(bin)){
    dat <- Rel_p[Rel_p$Segment == seg,]
    plot_x <- 'Dens_Lane'
    plot_y <- 'Hourly_Flow_per_lane'
    q <- 'Quantile_u'
  } else {
    dat <- Rel_bin[Rel_bin$Segment == seg,]
    plot_x <- 'Density_bin_Lane'
    plot_y <- 'Flow_Hour_Lane'
    q <- 'quantiles'
  }
  
  tt <- ggplot()+
    geom_point(data=dat, aes_string(x= plot_x,y = plot_y, color= q))+
    geom_segment(data = dens_flow_data,
                 aes(x = Density_cong_Lane, y = Axis,
                     xend = Density_cong_Lane, yend = Flow_cong_Hour_Lane,
                     color = quantiles), linetype = 'dashed') +
    geom_segment(data = dens_flow_data,
                 aes(x = Axis, y = Flow_cong_Hour_Lane,
                     xend = Density_cong_Lane, yend = Flow_cong_Hour_Lane,
                     color = quantiles), linetype = 'dashed') +
    # geom_smooth(span=0.75,se=F)+
    facet_grid(~Delay_type, scales = 'free')+
    # scale_y_continuous(minor_breaks = seq(0, 4000,50), breaks = seq(0,4000,100))+
    # scale_x_continuous(minor_breaks = seq(0,500,5), breaks = seq(0,500,10))+
    theme(legend.position=legend)+
    ggtitle(paste('Segment:',seg))
  ggplotly(tt)
  
}
```

Vertical and horizontal dashed lines indicate the Congested Density and Flow points. This values were manually determined by visually inspecting these plots. 

### Segment 1

```{r Density vs Flow seg1, fig.width = 12,echo = FALSE, message = FALSE}

dens_flow_plot(3,'', bin = TRUE)
```


## FLOW vs TT {.tabset .tabset-fade}


```{r dens_flow_plot, include=FALSE}

TT_flow_plot <- function(seg,legend='', bin = NA){
  
  TT_flow_data <- filter(dens_flow_tab, Segment == seg)
  
  flow_dens <- 
  if(is.na(bin)){
    dat <- Rel_p[Rel_p$Segment == seg,]
    plot_x <- 'TT_mean'
    plot_y <- 'Hourly_Flow'
    q <- 'Quantile_l'
  } else {
    dat <- Rel_bin[Rel_bin$Segment == seg,]
    plot_x <- 'TT_quantile'
    plot_y <- 'Flow'
    q <- 'quantiles'
  }
  
  tt <- ggplot()+
    geom_point(data=dat, aes_string(x= plot_x,y = plot_y, color= q))+
    # geom_smooth(span=0.75,se=F)+
    facet_grid(~Delay_type, scales = 'free')+
    # scale_y_continuous(minor_breaks = seq(0, 4000,50), breaks = seq(0,4000,100))+
    # scale_x_continuous(minor_breaks = seq(0,500,5), breaks = seq(0,500,10))+
    theme(legend.position=legend)+
    ggtitle(paste('Segment:',seg))
  (tt)
  
}
```


## DEMAND

```{r R^2, include=FALSE}

some_data <- Rel_bin %>%
  filter(Segment == 2, Delay_type == 'None', quantiles == '75%') %>%
  select(Density_bin_Lane, TT_quantile, Speed, Flow_Hour_Lane)  %>%
  arrange( Density_bin_Lane) %>%
  mutate(Index = seq(1:length(Flow_Hour_Lane)))

df <- list()
for (i in 1:length(some_data$Density_bin_Lane)){
  mod <- lm(data = some_data[1:i,],Flow_Hour_Lane ~ Density_bin_Lane)
  df[i] <- (summary(mod)$adj.r.squared)
}
df <- unlist(df)

some_data$R_sq <- df

g <- ggplot(some_data,aes(x= Density_bin_Lane, y = Flow_Hour_Lane, color = R_sq, text = R_sq)) +
  geom_point() +
  geom_smooth(span=0.75,se=F) 
ggplotly(g, tooltip = 'text')
  
```

Calculate Demand and DC.

```{r calculate Demand}

Rel_bin <- merge(Rel_bin, dens_flow_tab,
                 by = c('Delay_type','quantiles', 'Segment')) %>%
  mutate(Demand_Hour_Lane = ifelse(Density_bin_Lane <= Density_cong_Lane, 
                                   Flow_Hour_Lane,
                                   ifelse(Density_bin_Lane >= Density_cong_Lane 
                                          & Flow_Hour_Lane <= Flow_cong_Hour_Lane,
                                          Flow_cong_Hour_Lane + (Flow_cong_Hour_Lane - Flow_Hour_Lane),
                                          Flow_Hour_Lane)),
         DC_Lane = Demand_Hour_Lane/Flow_cong_Hour_Lane) 

```

## TTI vs DEMAND {.tabset .tabset-fade}

A look at the Density vs travel time plots. A generic smooting function has been added. 

```{r TTI vs Demand plot, include=FALSE}

demand_tti_plot <- function(seg,legend = '', sp = 1){
  tt <- ggplot()+
    geom_point(data=Rel_bin[Rel_bin$Segment == seg,],
               aes(x= Demand_Hour_Lane,y = TTI, color= quantiles))+
    # geom_smooth(data=Rel_bin[Rel_bin$Segment == seg,],
    #             aes(x= Demand,y = TTI, color= quantiles),span=sp,se=F)+
    facet_grid(~Delay_type, scales = 'free')+
    theme(legend.position=legend)+
    ggtitle(paste('Segment:',seg))
  ggplotly(tt)
}
```



### Segment 1

```{r TTI vs Demand seg1, fig.width = 12,echo = FALSE, message = FALSE}

demand_tti_plot(9,'',1)
```


## Prediction


The below code is used to develop the model based on the relationship between TTI and DC. 


```{r join model to table predict on DC, include = FALSE}
table(duplicated(Rel_bin[,1:5]))

# Rel_p <- filter(Rel, Segment %in% c(1:4,6:8))
Rel_p <- Rel

Rel_q <- Rel_p %>% 
  select(Segment, Delay_type, Density_bin_Lane, TT_q = TT_mean, Index) %>%
  data.table()

TT_q_table <- data.table(Rel_bin) %>% 
  select(Segment, Delay_type, Density_bin_Lane,
         TT_q = TT_quantile, quantiles,
         FF_quantile, Flow_cong_Hour_Lane, Density_cong_Lane) %>% data.table()

setkey(TT_q_table, NULL)

setkey(TT_q_table, Segment, Delay_type, Density_bin_Lane, TT_q)

join_TT <- TT_q_table[Rel_q, roll = -Inf, .(TT_quantile_u = x.TT_q,
                                            TT_mean = i.TT_q,
                                            Delay_type = Delay_type,
                                            Index = Index,
                                            Segment = Segment,
                                            Density_bin_Lane = Density_bin_Lane,
                                            FF_u = FF_quantile,
                                            Quantile_u = quantiles,
                                            Flow_cong_Hour_Lane_u = Flow_cong_Hour_Lane,
                                            Density_cong_Lane_u = Density_cong_Lane)] %>%
  select(Segment, Delay_type, Density_bin_Lane, TT_mean, 
         TT_quantile_u, Quantile_u, Flow_cong_Hour_Lane_u, Density_cong_Lane_u, FF_u, Index) %>%
  data.table()

join_TT <- TT_q_table[join_TT, roll = T, .(TT_quantile_l = x.TT_q,
                                           TT_quantile_u = i.TT_quantile_u,
                                           TT_mean = TT_mean,
                                           FF_l = FF_quantile,
                                           FF_u = FF_u,
                                           Delay_type = Delay_type,
                                           Quantile_u = Quantile_u,
                                           Quantile_l = quantiles,
                                           Flow_cong_Hour_Lane_u = Flow_cong_Hour_Lane_u,
                                           Density_cong_Lane_u = Density_cong_Lane_u,
                                           Flow_cong_Hour_Lane_l = Flow_cong_Hour_Lane,
                                           Density_cong_Lane_l = Density_cong_Lane,
                                           Index = Index,
                                           # br = br,
                                           Segment = Segment,
                                           Density_bin_Lane = Density_bin_Lane)]


head(join_TT)
join_TT <- join_TT[!duplicated(join_TT$Index),]

Rel_p <- merge(Rel_p, 
                 join_TT[,c('Index','TT_quantile_u', 'TT_quantile_l',
                            'Quantile_u','Quantile_l','Flow_cong_Hour_Lane_u','Density_cong_Lane_u','FF_u',
                            'Flow_cong_Hour_Lane_l','Density_cong_Lane_l','FF_l')],
                 by = 'Index', all.x=TRUE)

table(is.na(Rel_p$Flow_cong_Lane))

Rel_p <- Rel_p %>%
  mutate(TT_quantile_l = ifelse(is.na(TT_quantile_l),
                                TT_quantile_u, 
                                TT_quantile_l),
         TT_quantile_u = ifelse(is.na(TT_quantile_u), 
                                TT_quantile_l, 
                                TT_quantile_u),
         Quantile_u = if_else(is.na(Quantile_u),
                              Quantile_l,
                              Quantile_u),
         Quantile_l = if_else(is.na(Quantile_l),
                              Quantile_u,
                              Quantile_l),
         Diff = ifelse(TT_quantile_u == TT_quantile_l,
                       0,
                       (TT_mean-TT_quantile_l)/(TT_quantile_u - TT_quantile_l)),
         Density_cong_Lane = ifelse(is.na(Density_cong_Lane_l),
                               Density_cong_Lane_u, 
                               ifelse(is.na(Density_cong_Lane_u),
                                      Density_cong_Lane_l,
                                      Density_cong_Lane_l +
                                        (Density_cong_Lane_u - Density_cong_Lane_l) * Diff)),
         Flow_cong_Hour_Lane = ifelse(is.na(Flow_cong_Hour_Lane_l),
                            Flow_cong_Hour_Lane_u,
                            ifelse(is.na(Flow_cong_Hour_Lane_u),
                                   Flow_cong_Hour_Lane_l,
                                   Flow_cong_Hour_Lane_l + (Flow_cong_Hour_Lane_u - Flow_cong_Hour_Lane_l) * Diff)),
         Demand_Hour_Lane = ifelse(Density_bin_Lane <= Density_cong_Lane, 
                                   Hourly_Flow_per_lane, 2 * Flow_cong_Hour_Lane - Hourly_Flow_per_lane),
         DC = Demand_Hour_Lane / Flow_cong_Hour_Lane,
         FF = ifelse(is.na(FF_l),
                     FF_u,
                     ifelse(is.na(FF_u),
                            FF_l,
                            FF_l + (FF_u - FF_l) * Diff)),
         TTI = TT_mean / (Length/FF * 60))
```

```{r}
Rel_p_6 <- Rel_p %>%
  filter(Segment ==6) %>%
  arrange(DateTime)

Rel_p_7 <- Rel_p %>%
  filter(Segment ==7) %>%
  arrange(DateTime)

Rel_p_test <- Rel_p %>%
  filter(!Segment == 6) %>%
  mutate(DC_new = DC)

Rel_p_6 <- merge(Rel_p_6,
                 select(Rel_p_7,DateTime, DC_new = DC),all.x='TRUE')

Rel_p_test <- dplyr::bind_rows(Rel_p_test, Rel_p_6)
```


```{r develop model, message = TRUE}

q <-     10
br1 <-    1.5
factor <-  1
# br2 <-    0.9
q <- paste(q, '%', sep ='')

sample_data <- Rel_p_test %>%
  filter(Segment == 9, Delay_type == 'Crash', Quantile_l == q, !is.na(DC_new)) %>%
  select(DC_new, TTI, TT_mean) 

# sample_data <- Rel_p_test %>%
#   filter(Segment == 2, Delay_type == 'None', quantiles == q, !is.na(DC_Lane)) %>%
#   select(DC_Lane, TTI, TT_quantile) 

formulaExp <- as.formula(TTI ~((DC_new <= br1) +(DC_new > br1) * ( mu * (DC_new ^ b))) * factor)

b <- 3
mu <- 1.5

sample_nls <- nls(formulaExp, data = sample_data, start = list(mu = mu, b = b))
plotfit(sample_nls, smooth = TRUE)

ggplot(sample_data, aes(x = DC_new, y = TTI))+
  geom_point()


#predict(sample_nls, data.frame(DC = 1.047))
```




```{r create prediction model, include = FALSE}

func_exp <- function(x) {
  nls(
    TTI ~(((DC_new <= br) + (DC_new > br) * (mu * (DC_new ^ b))) * factor),
    start = list(mu = 1.5, b = 3),
    data = x,
    nls.control(maxiter = 50))
}

# func_exp <- function(x) {
#   lm(TTI ~ splines::bs(DC, knots = knots, data = x))
# }


breaks <- read.csv('./model_breaks_3_6_19.csv')
Rel_p_test <- merge(Rel_p_test, breaks) %>%
  filter(DC_new > 0,
         !is.na(DC_new))

model_nls <- Rel_p_test %>%
  # filter(Segment == 1) %>%
  nest(-Segment, -Delay_type, -Quantile_l) %>%
  filter(Delay_type %in% c('None', 'Crash','Weather'),
         # Segment %in% c(1:4,6:9),
         Quantile_l %in% c('5%','10%','25%','50%','75%','90%','95%')) %>%
  mutate(fit = purrr::map(data, func_exp))

```


```{r}
upper_lower_model <- function(df){
  Rel_p_test <- df
  u_cols <- c('Segment', 'Delay_type', 'Quantile_u', 'DC_new', 'Index', 'br', 'factor')
  Rel_p_u <- Rel_p_test %>%
    select(one_of(u_cols)) %>%
    select(everything(), Quantiles = Quantile_u) %>%
    nest(-Segment, -Delay_type, -Quantiles) %>%
    merge(model_nls %>% select(Segment, Delay_type, Quantiles = Quantile_l, fit)) %>%
    as.tibble() %>%
    mutate(pred = map2(fit,data,predict)) %>%
    as.tibble() %>%
    unnest(data,pred)
  
  l_cols <- c('Segment', 'Delay_type', 'Quantile_l', 'DC_new', 'Index', 'br', 'factor')
  Rel_p_l <- Rel_p_test %>% 
    select(one_of(l_cols)) %>%
    select(everything(), Quantiles = Quantile_l) %>%
    nest(-Segment, -Delay_type, -Quantiles) %>%
    merge(model_nls %>% select(Segment, Delay_type, Quantiles = Quantile_l, fit)) %>%
    as.tibble() %>%
    mutate(pred = map2(fit,data,predict)) %>%
    as.tibble() %>%
    unnest(data,pred)
  
  Rel_p_test <- merge(Rel_p_test, select(Rel_p_u, Index, pred_u = pred), all.x = TRUE) %>%
    merge(select(Rel_p_l, Index, pred_l = pred), all.x = TRUE) %>%
    mutate(pred_final = ifelse(is.na(pred_l), 
                               pred_u,
                               ifelse(is.na(pred_u),
                                      pred_l,
                                      pred_l + (pred_u - pred_l) * Diff)),
           Error = abs(pred_final - TTI))
  return(Rel_p_test)
}
rm(Rel_p_l, Rel_p_u, join_TT, Rel_q, TT_q_table)

Rel_p = upper_lower_model(Rel_p_test)

Rel_p$pred_final <- ifelse(Rel_p$pred_final>6,6,Rel_p$pred_final)
```

## Prediction Results {.tabset .tabset-fade}

```{r prediction plotting fuction, include = FALSE}
plot_predict <- function(Seg){
  
  pr <- ggplot(filter(Rel_p,Segment == Seg), aes(x= TTI,y=pred_final, color = Quantile_l))+
    geom_point() +
    geom_abline(intercept = 0, slope = 1, linetype = 'dashed', color = 'red') +
    # scale_x_continuous(breaks = c(1,2,3,4,5))+
    # scale_y_continuous(breaks = c(1,2,3,4,5,6))+
    facet_grid(~Delay_type)
  pr
}


```


### Prediction Segment 1

```{r plot predict seg1, fig.width=12}
plot_predict(1)
```

## Analyse Prediction Results {.tabset .tabset-fade}

### SEGMENT 6

```{r SEGMENT 6 RESULTS}

segment1 <- Rel_p_test %>%
  filter(Segment == 1) %>%
  droplevels()
```

### SEGMENT 7

```{r SEGMENT 7 RESULTS}

segment7 <- Rel_p %>%
  filter(Segment == 7
         # TTI > 1.25 & TTI < 1.3,
         # Error < 0.5
         # is.na(Quantile_u)
         ) %>%
  arrange(desc(Error))

```


## HEATMAP {.tabset .tabset-fade}


```{r heatmap,include = FALSE, message = FALSE}

TT_heat <-function(data,seg, model, alternative = ' '){ 
  
  heat <- data %>%
    # filter(Segment == seg) %>% 
    # mutate(direction = ifelse(Segment < 6,'EB','WB')) %>%
    # filter(direction  == seg) %>% 
    # select(DateTime, TT_mean, Length, pred = pred_final) %>% 
    mutate(HourMin = format(DateTime, '%H:%M'),
           YearDate = as.POSIXct(format(DateTime, '%Y-%m-%d')),
           mod = model,
           # TTI = ifelse(mod == TRUE,
           #              pred,
           #              TT_mean/(Length/60 * 60)),
           TTI_Cat = factor(ifelse(TTI > 4.0,'>4.0 TTI',
                                   ifelse(TTI <= 4.0 & TTI > 3.5,
                                          '3.5 TTI - 4.0 TTI',
                                          ifelse(TTI <= 3.5 & TTI > 3.0,
                                                 '3.0 TTI - 3.5 TTI',
                                                 ifelse(TTI <= 3.0 & TTI > 2.5,
                                                        '2.5 TTI - 3.0 TTI',
                                                        ifelse(TTI <= 2.5 & TTI > 2.0,
                                                               '2.0 TTI - 2.5 TTI',
                                                               ifelse(TTI <= 2.0 & TTI > 1.5,
                                                                      '1.5 TTI - 2.0 TTI',
                                                                      ifelse(TTI <= 1.5 & TTI > 1.25,
                                                                             '1.25 TTI - 1.5 TTI',
                                                                             ifelse(TTI <= 1.25 & TTI > 1.0 ,
                                                                                    '1.0 TTI - 1.25 TTI',
                                                                                    ifelse(TTI <= 1.0 ,
                                                                                           '<1.0 TT', NA))))))))),
                            levels = (c('>4.0 TTI',
                                        '3.5 TTI - 4.0 TTI',
                                        '3.0 TTI - 3.5 TTI',
                                        '2.5 TTI - 3.0 TTI',
                                        '2.0 TTI - 2.5 TTI',
                                        '1.5 TTI - 2.0 TTI',
                                        '1.25 TTI - 1.5 TTI',
                                        '1.0 TTI - 1.25 TTI',
                                        '<1.0 TT')))) 
  
  
library(RColorBrewer)
myColors <- colors()[c(24,30,507,552,59,53,652,256,258)]
names(myColors) <- levels(heat$TTI_Cat)
colScale <- scale_colour_manual(name = "TTI_Cat",values = myColors)
fillScale <- scale_fill_manual(name = "TTI_Cat",values = myColors)
break_axis <- c('06:00','09:00','12:00','15:00','18:00','21:00')

predicted_TF <- ifelse(model == TRUE,'predicted values','measured values')

g <- ggplot(heat) +
  geom_tile(aes(x=YearDate,y=HourMin,color = TTI_Cat, fill = TTI_Cat))  +
  theme_tufte(base_size = 15) +
  scale_y_discrete(breaks = break_axis) +
  colScale + fillScale +
  ggtitle(paste('Direction ', seg, 'TTI Heatmap','-',predicted_TF,alternative))
return(g)
}
```

### SEGMENT 

```{r}
Rel_p$Hour <- as.numeric(Rel_p$Hour)
Rel_p$minute <- minute(Rel_p$DateTime)
Rel_p$hr_min <- Rel_p$Hour + Rel_p$minute/60
Rel_p <- Rel_p %>% filter(Segment != 1)


Rel_p$DayPeriod <- ifelse((Rel_p$hr_min >= 6.0) & (Rel_p$hr_min < 9.0), 'Morning',
                          ifelse((Rel_p$hr_min >=9.0) & (Rel_p$hr_min < 15.5), 'Lunch',
                                 ifelse((Rel_p$hr_min >= 15.5) & (Rel_p$hr_min < 18.5),'Afternoon',
                                        ifelse((Rel_p$hr_min >= 18.5) & (Rel_p$hr_min < 23), 'Evening',
                                               ifelse((Rel_p$hr_min >= 23) | (Rel_p$hr_min < 6.0), 'Night','NA')))))

# Rel_p$DayPeriod <- ifelse((Rel_p$hr_min >= 7.5) & (Rel_p$hr_min < 8.5), 'Morning',
#                           ifelse((Rel_p$hr_min >=8.5) & (Rel_p$hr_min < 17.25), 'Lunch',
#                                  ifelse((Rel_p$hr_min >= 17.25) & (Rel_p$hr_min < 18.25),'Afternoon',
#                                         ifelse((Rel_p$hr_min >= 18.25) & (Rel_p$hr_min < 23), 'Evening',
#                                                ifelse((Rel_p$hr_min >= 23) | (Rel_p$hr_min < 7.5), 'Night','NA')))))

# Rel_p$DayPeriod <- ifelse((Rel_p$hr_min >= 5.0) & (Rel_p$hr_min < 10.0), 'Morning',
#                           ifelse((Rel_p$hr_min >=10.0) & (Rel_p$hr_min < 14.0), 'Lunch',
#                                  ifelse((Rel_p$hr_min >= 14.0) & (Rel_p$hr_min < 19.0),'Afternoon',
#                                         ifelse((Rel_p$hr_min >= 19.0) & (Rel_p$hr_min < 23), 'Evening',
#                                                ifelse((Rel_p$hr_min >= 23) | (Rel_p$hr_min < 5.0), 'Night','NA')))))

```


```{r heatmap seg1, fig.width=12}
segment = 9
# TT_heat(Rel_p,segment, model = FALSE)
# 
# TT_heat(Rel_p,segment, model = TRUE)

```


## Thermometer



```{r thermometer existing,include = FALSE, message = FALSE}

TT_therm <- Rel_p %>%
  filter(Segment == segment,
         DayPeriod %in% c('Morning','Afternoon')) %>%
  filter(Segment == segment) %>%
  mutate(YearDay = yday(DateTime))%>%
  select(DateTime, TTI , YearDay)

myColors <- colors()[c(24,30,507,552,59,53,652,256,258)]
# myColors <- colors()[c(29,30,507,552,59,53,652,256,258)]
quants <- seq(.025,.975,.05)
therm <- TT_therm %>%
  summarise(quantiles = list(sprintf("%1.1f%%", quants*100)),
            TTI = list(quantile( TTI ,quants))) %>%
  unnest() %>%
  # mutate(Title = 'Segment 1 Exist') %>%
  select(quantiles, TTI)
therm_table <- flextable(therm)
# theme_vanilla(therm_table)
therm_table <- bg(therm_table, i = ~ TTI > 4, j =  ~ TTI ,bg = myColors[[1]])
therm_table <- bg(therm_table, i = ~ TTI <= 4.0 & TTI> 3.5,j =  ~ TTI ,bg = myColors[[2]])
therm_table <- bg(therm_table, i = ~ TTI <= 3.5 & TTI> 3.0,j =  ~ TTI ,bg = myColors[[3]])
therm_table <- bg(therm_table, i = ~ TTI <= 3.0 & TTI> 2.5,j =  ~ TTI ,bg = myColors[[4]])
therm_table <- bg(therm_table, i = ~ TTI <= 2.5 & TTI> 2.0,j =  ~ TTI ,bg = myColors[[5]])
therm_table <- bg(therm_table, i = ~ TTI <= 2.0 & TTI> 1.5,j =  ~ TTI ,bg = myColors[[6]])
therm_table <- bg(therm_table, i = ~ TTI <= 1.5 & TTI> 1.25,j =  ~ TTI ,bg = myColors[[7]])
therm_table <- bg(therm_table, i = ~ TTI <= 1.25 & TTI> 1.0,j =  ~ TTI ,bg = myColors[[8]])
therm_table <- bg(therm_table, i = ~ TTI <= 1.0 ,j =  ~ TTI ,bg = myColors[[9]])
therm_table <- color(therm_table, j =  ~ TTI , color = "white")
therm_table <- color(therm_table, i = ~ TTI <= 1.5 & TTI> 1.25,j =  ~ TTI , color = "black")
therm_table <- add_header(therm_table, quantiles = segment, TTI = 'Exist')
# read_docx() %>% 
#   # body_add_flextable(therm_table) %>% 
#   body_add_img(therm_table) %>% 
#   print(target = "flextable.docx")
therm_table

```

```{r}
Rel_p %>%
  select(DateTime, TT_mean, VMT_total, Vol_15_min, Speed, Segment) %>%
  write.csv('Rel_p.csv')
```


```{r}
getwd()
```


```{r thermometer predicted ,include = FALSE, message = FALSE, fig.height=25}

# segment = 9
# TT_therm <- MNPass_2040_FF %>%
# # TT_therm <- MNPass_2040_remaining_lanes %>%
#   filter(Segment == segment,
#          DayPeriod %in% c('Morning','Afternoon')) %>%
#   filter(Segment == segment) %>%
#   mutate(YearDay = yday(DateTime))%>%
#   select(DateTime, pred_final , YearDay)
# 
# myColors <- colors()[c(24,30,507,552,59,53,652,256,258)]
# 
# quants <- seq(.025,.975,.05)
# therm <- TT_therm %>%
#   summarise(quantiles = list(sprintf("%1.1f%%", quants*100)),
#             TTI_final = list(quantile(pred_final ,quants, na.rm = TRUE))) %>%
#   unnest() %>%
#   # mutate(Title = 'Segment 1 Exist') %>%
#   select(quantiles, TTI_final)
# 
# therm_table <- flextable(therm)
# # theme_vanilla(therm_table)
# therm_table <- bg(therm_table, i = ~ TTI_final > 4, j =  ~ TTI_final ,bg = myColors[[1]])
# therm_table <- bg(therm_table, i = ~ TTI_final <= 4.0 & TTI_final> 3.5,j =  ~ TTI_final ,bg = myColors[[2]])
# therm_table <- bg(therm_table, i = ~ TTI_final <= 3.5 & TTI_final> 3.0,j =  ~ TTI_final ,bg = myColors[[3]])
# therm_table <- bg(therm_table, i = ~ TTI_final <= 3.0 & TTI_final> 2.5,j =  ~ TTI_final ,bg = myColors[[4]])
# therm_table <- bg(therm_table, i = ~ TTI_final <= 2.5 & TTI_final> 2.0,j =  ~ TTI_final ,bg = myColors[[5]])
# therm_table <- bg(therm_table, i = ~ TTI_final <= 2.0 & TTI_final> 1.5,j =  ~ TTI_final ,bg = myColors[[6]])
# therm_table <- bg(therm_table, i = ~ TTI_final <= 1.5 & TTI_final> 1.25,j =  ~ TTI_final ,bg = myColors[[7]])
# therm_table <- bg(therm_table, i = ~ TTI_final <= 1.25 & TTI_final> 1.0,j =  ~ TTI_final ,bg = myColors[[8]])
# therm_table <- bg(therm_table, i = ~ TTI_final <= 1.0 ,j =  ~ TTI_final ,bg = myColors[[9]])
# therm_table <- color(therm_table, j =  ~ TTI_final , color = "white")
# therm_table <- color(therm_table, i = ~ TTI_final <= 1.5 & TTI_final> 1.25,j =  ~ TTI_final , color = "black")
# therm_table <- add_header(therm_table, quantiles = segment, TTI_final = 'Pred ')
# 
# # read_docx() %>% 
# #   # body_add_flextable(therm_table) %>% 
# #   body_add_img(therm_table) %>% 
# #   print(target = "flextable.docx")
# therm_table
```


## ALTERNATIVES

```{r}
my_cols <- c('Segment', 'DateTime', 'Delay_type', 'Quantile_u',
             'Quantile_l', 'Demand_Hour_Lane', 'Flow_cong_Hour_Lane', 'Density_cong_Lane',
             'Index', 'br','factor', 'Lanes', 'Diff', 'TTI', 'TT_mean','Length','DayPeriod','Hour','hr_min')

Exist_Demand <- Rel_p %>%
  select(one_of(my_cols))%>%
  mutate(Demand_Hour_all_lanes = Demand_Hour_Lane * Lanes)
```

```{r}
# List of segments
segs <- 1:9
#create list of various alternatives
alts_list <- rep(c('No_change','Add_GP','Add_MNPass','Add_HOV'), length(segs))

#vector of the various additional lanes needed in each alternative
lane_add <- rep(c(0,1,0,0), length(segs))


#create dataframe to combine the above details
# alts <- data.frame('Alternatives' = alts_list, 'Segment' = segs, 'Lanes_add' = lane_add, 'demand_change' = demand_change) 
  
rm(segs,alts_list, lane_add, demand_change)

forecasts <- read.csv('Forecasts.csv', stringsAsFactors = FALSE) %>%
  melt(id.vars = c('Segment','Existing'), measure.vars = c('No.Build','GP','MnPASS'), value.name = 'Demand_2040') %>%
  mutate(Demand_2040 = as.numeric(gsub(',','',Demand_2040)),
         Existing = as.numeric(gsub(',','',Existing)),
         Demand_2040_change = Demand_2040 / Existing,
         Lanes_add = ifelse(variable == 'No.Build',0,1))
```


```{r}

# load external dataset
# dataset is a list of previously calculated Demand equations for MNPass vs total demand. 
# dataset was developed for 35W Gap project.
# these equations will be used to calculate MNPass demand with the remaining demand spread across the 
# remaining GP lanes
MNPass_eqt <- read.csv('./mnpass_equations.csv') %>%
  mutate(Max_MnPASS_Demand = as.numeric(str_extract(Max_MnPASS_Demand,"\\d+")))

# MNPass_eqt <-  MNPass_eqt %>%
#   mutate(Alpha  = Alpha * 1.15,
#          Beta = Beta *1.15)

MNPass_eqt <- MNPass_eqt %>%
  mutate(Max_MnPASS_Demand = ifelse(Max_MnPASS_Demand == 1600,1600,NA))
MNPass_eqt
```


### No Change

```{r}

no_change_2040 <- forecasts %>%
  filter(variable == 'No.Build') %>%
  select(Segment, Demand_2040_change, Lanes_add) %>%
  merge(Exist_Demand) %>%
  mutate(offpeak = 'Off_Peak') %>%
  mutate(Time_Period = ifelse(DayPeriod %in% c('Morning','Afternoon'), DayPeriod, offpeak)) %>%
  mutate(Demand_Hour_2040_all_lanes  = Demand_Hour_all_lanes * Demand_2040_change,
         Demand_Hour_2040_per_lane = Demand_Hour_2040_all_lanes / (Lanes + Lanes_add)) %>%
  mutate(DC_new = Demand_Hour_2040_per_lane/Flow_cong_Hour_Lane)
         # ThruP = ifelse(Density_bin <= Density_cong, Flow,
         #                ifelse(Density_bin >= Density_cong & Flow <= Flow_cong,
         #                       Flow_cong + (Flow_cong - Flow),
         #                       Flow)))



no_change_2040 <- upper_lower_model(no_change_2040)
```

### Add GP

```{r}

GP_2040 <- forecasts %>%
  filter(variable == 'GP') %>%
  select(Segment, Demand_2040_change, Lanes_add) %>%
  merge(Exist_Demand) %>%
  mutate(offpeak = 'Off_Peak') %>%
  mutate(Time_Period = ifelse(DayPeriod %in% c('Morning','Afternoon'), DayPeriod, offpeak)) %>%
  mutate(Demand_Hour_2040_all_lanes  = Demand_Hour_all_lanes * Demand_2040_change,
         Demand_Hour_2040_per_lane = Demand_Hour_2040_all_lanes / (Lanes + Lanes_add)) %>%
  mutate(DC_new = Demand_Hour_2040_per_lane/Flow_cong_Hour_Lane)

GP_2040 <- upper_lower_model(GP_2040)
```


### Add MNPass

```{r}

MNPass_2040 <- forecasts %>%
  filter(variable == 'MnPASS') %>%
  select(Segment, Demand_2040_change, Lanes_add) %>%
  merge(Exist_Demand) %>%
  mutate(Time_Period = ifelse((DayPeriod %in% c('Morning','Afternoon')) & (weekdays(DateTime) %in% wkday), DayPeriod, 'Off_Peak')) %>%
  merge(MNPass_eqt) %>%
  mutate(Demand_Hour_2040_all_lanes  = Demand_Hour_all_lanes * Demand_2040_change,
         MNPass_demand_hour = ifelse(Function_Type == 'Exp', 
                                     # Alpha * exp(Beta * (Demand_Hour_2040_all_lanes / (Lanes + Lanes_add))),
                                     Alpha * exp(Beta * Demand_Hour_2040_all_lanes),
                                     ifelse(Function_Type == 'Power', 
                                            # Alpha * (Demand_Hour_2040_all_lanes / (Lanes + Lanes_add)) ^ Beta,
                                            Alpha * Demand_Hour_2040_all_lanes ^ Beta,
                                            NA)),
         Max_MnPASS_Demand_hour = ifelse(is.na(Max_MnPASS_Demand),
                                    Demand_Hour_2040_all_lanes / (Lanes + Lanes_add),
                                    Max_MnPASS_Demand),
         MNPass_demand_hour_limit = ifelse(Time_Period == 'Off_Peak',
                                           Max_MnPASS_Demand_hour,
                                           Max_MnPASS_Demand),
         MNPass_demand_hour_final = ifelse(MNPass_demand_hour < MNPass_demand_hour_limit,
                                           MNPass_demand_hour,
                                           MNPass_demand_hour_limit),
         Remaining_all_lanes_demand_hour =  Demand_Hour_2040_all_lanes - MNPass_demand_hour_final,
         Remaining_per_lane_demand_hour = Remaining_all_lanes_demand_hour/Lanes)

MNPass_2040_FF <- upper_lower_model(mutate(MNPass_2040,
                                        DC_new = (MNPass_demand_hour_final/Flow_cong_Hour_Lane)))

MNPass_2040_remaining_lanes <- upper_lower_model(mutate(MNPass_2040,
                                        DC_new = Remaining_per_lane_demand_hour/Flow_cong_Hour_Lane))
```

## Alternatives Heatmaps

```{r}
segment = 8
# TT_heat(no_change_2040,segment, model = TRUE,'no_change_2040')
# TT_heat(GP_2040,segment, model = TRUE, 'GP_2040')
# TT_heat(MNPass_2040_FF,segment, model = TRUE, 'MNPass_2040')
# TT_heat(MNPass_2040_remaining_lanes,segment, model = TRUE, 'MNPass_2040_remaining_lanes')
```

```{r}
review = MNPass_2040_FF %>%
  filter(segment==9,
         pred_final > 2)
dim(review)
```



```{r stacked bar chart}

demand_flow_factor <- Rel_p%>%
  mutate(doy = yday(DateTime)) %>%
  group_by(Segment,DayPeriod, doy) %>%
  summarise(Demand_Hour_lane_day_dp_sum = sum(Demand_Hour_Lane),
            Flow_Hour_lane_day_dp_sum = sum(Hourly_Flow_per_lane),
            Length = mean(Length), FF = round(mean(FF),0)) %>%
  mutate(demand_flow_factor = Demand_Hour_lane_day_dp_sum /
           Flow_Hour_lane_day_dp_sum)
# demand_flow_factor$demand_flow_factor <- 1


vehicle_tru <- function(alternative,dp = c('Morning','Afternoon'), grpby = 'DayPeriod'){

d <- Rel_p %>%
  mutate(doy = yday(DateTime)) %>%
  filter(DayPeriod %in% dp) %>%
  select(Segment, VMT_total_SRF, Hourly_Flow_per_lane , WeekDay, DateTime, Hour, Lanes, DayPeriod, doy, Length, FF) %>%
  merge(select(alternative, Segment, DateTime, Demand_2040_change, Lanes_add, Demand_Hour_2040_all_lanes)) %>%
  mutate(Flow_Hour_2040_all_lanes = Hourly_Flow_per_lane * Demand_2040_change * Lanes) %>%
  group_by_('Segment',grpby, 'doy') %>%
  summarise(Demand_Hour_2040_all_lanes_day_dp_sum = sum(Demand_Hour_2040_all_lanes),
            Flow_Hour_2040_all_lanes_day_dp_sum = sum(Flow_Hour_2040_all_lanes),
            Length = mean(Length), FF = round(mean(FF),0)) %>%
  mutate(demand_flow_factor = Demand_Hour_2040_all_lanes_day_dp_sum /
           Flow_Hour_2040_all_lanes_day_dp_sum)
return(d)
}

vehicle_tru_mnPass_ff <- function(alternative, dp = c('Morning','Afternoon'), grpby = 'DayPeriod'){

d <- Rel_p %>%
  mutate(doy = yday(DateTime)) %>%
  filter(DayPeriod %in% dp) %>%
  select(Segment, VMT_total_SRF, Hourly_Flow_per_lane , WeekDay, DateTime, Hour, Lanes, DayPeriod, doy, Length, FF) %>%
  merge(select(alternative, Segment, DateTime, Demand_2040_change, Lanes_add, MNPass_demand_hour_final)) %>%
  # mutate(Flow_Hour_2040_mnpass_lane = ifelse(Hourly_Flow_per_lane * Demand_2040_change>1600,
  #                                            1600,
  #                                            Hourly_Flow_per_lane * Demand_2040_change)) %>%
  # mutate(Flow_Hour_2040_mnpass_lane = (Hourly_Flow_per_lane * Demand_2040_change))%>%
  mutate(Flow_Hour_2040_mnpass_lane = MNPass_demand_hour_final) %>%
  group_by_('Segment',grpby, 'doy') %>%
  summarise(Demand_Hour_2040_all_lanes_day_dp_sum = sum(MNPass_demand_hour_final),
            Flow_Hour_2040_mnpass_lane_day_dp_sum = sum(Flow_Hour_2040_mnpass_lane),
            Length = mean(Length), FF = round(mean(FF),0)) %>%
  mutate(demand_flow_factor = Demand_Hour_2040_all_lanes_day_dp_sum /
           Flow_Hour_2040_mnpass_lane_day_dp_sum)
return(d)
}

vehicle_tru_mnPass_remain <- function(alternative,dp = c('Morning','Afternoon'), grpby = 'DayPeriod'){

d <- Rel_p %>%
  mutate(doy = yday(DateTime)) %>%
  filter(DayPeriod %in% dp) %>%
  select(Segment, VMT_total_SRF, Hourly_Flow_per_lane , WeekDay, DateTime, Hour, Lanes, DayPeriod, doy, Length, FF) %>%
  merge(select(alternative, Segment, DateTime, Demand_2040_change, Lanes_add, Remaining_all_lanes_demand_hour)) %>%
  mutate(Flow_Hour_2040_all_lanes = Hourly_Flow_per_lane * Demand_2040_change * Lanes) %>%
  group_by_('Segment',grpby, 'doy') %>%
  summarise(Demand_Hour_2040_all_lanes_day_dp_sum = sum(Remaining_all_lanes_demand_hour),
            Flow_Hour_2040_all_lanes_day_dp_sum = sum(Flow_Hour_2040_all_lanes),
            Length = mean(Length), FF = round(mean(FF),0)) %>%
  mutate(demand_flow_factor = Demand_Hour_2040_all_lanes_day_dp_sum /
           Flow_Hour_2040_remain_lanes_day_dp_sum)
return(d)
}



'%!in%' <- function(x,y)!('%in%'(x,y))


agg_vehicle_thru <- function(input_d, alternative, group,dp = c('Morning','Afternoon')){

# input_d <-  vehicle_no_change
# alternative <- no_change_2040
# # group <- 'direction'
# dp = c('Morning','Afternoon')
  
  
throughput <- alternative %>%
  mutate(doy = yday(DateTime)) %>%
  filter(DayPeriod %in% dp) %>%
  merge(input_d) %>%
  mutate(Flow_2040 = Demand_Hour_2040_all_lanes / demand_flow_factor,
         VMT_2040_15 = Flow_2040 * 0.25 * Length,
         wkday=weekdays(.$DateTime),
         direction = ifelse(Segment < 6,'EB','WB')) %>%
         # cuts = cut(.$pred_final,bins,echo.lowest = TRUE),
         # TTI = extract_last_no(cuts)) %>%
  select(DateTime, Segment, wkday, VMT_2040_15, doy, TTI = pred_final, direction, Length, FF) %>%
  filter(wkday %!in% c('Saturday','Sunday')) %>%
  mutate(TT_hour = (TTI * Length) / FF) 

dir_len <- throughput %>%
  group_by(Segment, direction) %>%
  summarise(m = mean(Length),
            f = mean(FF)) %>%
  # group_by(Segment) %>%
  group_by(direction) %>%
  summarise(direction_length = sum(m),
            FF_direction = mean(f))

throughput <- throughput %>%
  merge(dir_len) %>%
  group_by(DateTime, direction) %>%
  # group_by(DateTime, Segment) %>%
  summarise(VMT_direction_15min = sum(VMT_2040_15),
            TT_hour_direction_15min = sum(TT_hour),
            direction_length  = max(direction_length),
            FF_direction = max(FF_direction)) %>%
  mutate(FF_TT_hour_direction = direction_length / FF_direction,
         TTI = TT_hour_direction_15min / FF_TT_hour_direction) %>%
  mutate(TTI_Cat = factor(ifelse(TTI > 4.0,'>4.0 TTI',
                   ifelse(TTI <= 4.0 & TTI > 3.5,
                      '3.5 TTI - 4.0 TTI',
                      ifelse(TTI <= 3.5 & TTI > 3.0,
                             '3.0 TTI - 3.5 TTI',
                             ifelse(TTI <= 3.0 & TTI > 2.5,
                                    '2.5 TTI - 3.0 TTI',
                                    ifelse(TTI <= 2.5 & TTI > 2.0,
                                           '2.0 TTI - 2.5 TTI',
                                           ifelse(TTI <= 2.0 & TTI > 1.5,
                                                  '1.5 TTI - 2.0 TTI',
                                                  ifelse(TTI <= 1.5 & TTI > 1.25,
                                                         '1.25 TTI - 1.5 TTI',
                                                         ifelse(TTI <= 1.25 & TTI > 1.0 ,
                                                                '1.0 TTI - 1.25 TTI',
                                                                ifelse(TTI <= 1.0 ,
                                                                       '<1.0 TTI', NA))))))))),
                   
                   levels = (c('>4.0 TTI',
                               '3.5 TTI - 4.0 TTI',
                               '3.0 TTI - 3.5 TTI',
                               '2.5 TTI - 3.0 TTI',
                               '2.0 TTI - 2.5 TTI',
                               '1.5 TTI - 2.0 TTI',
                               '1.25 TTI - 1.5 TTI',
                               '1.0 TTI - 1.25 TTI',
                               '<1.0 TTI')))) %>%
  # group_by(Segment, TTI_Cat) %>%
  group_by(direction, TTI_Cat) %>%
  summarise(thru = sum(VMT_direction_15min)/261,
            Length = mean(direction_length)) %>%
  mutate(Vol = thru/Length)

return(throughput)

}

agg_PTI <- function(input_d, alternative, group){

PTI <- alternative %>%
  mutate(doy = yday(DateTime)) %>%
  filter(DayPeriod %in% c('Morning','Afternoon')) %>%
  merge(input_d) %>%
  mutate(Flow_2040 = Demand_Hour_2040_all_lanes / demand_flow_factor,
         VMT_2040_15 = Flow_2040 * 0.25 * Length,
         wkday=weekdays(.$DateTime),
         direction = ifelse(Segment < 6,'EB','WB')) %>%
         # cuts = cut(.$pred_final,bins,echo.lowest = TRUE),
         # TTI = extract_last_no(cuts)) %>%
  select(DateTime, Segment, wkday, VMT_2040_15, doy, TTI = pred_final, direction, Length, FF) %>%
  filter(wkday %!in% c('Saturday','Sunday')) %>%
  mutate(TT_hour = (TTI * Length) / FF) 

dir_len <- PTI %>%
  group_by(Segment, direction) %>%
  summarise(m = mean(Length),
            f = mean(FF)) %>%
  group_by(direction) %>%
  summarise(direction_length = sum(m),
            FF_direction = mean(f))

PTI <- PTI %>%
  merge(dir_len) %>%
  group_by(DateTime, direction) %>%
  # group_by(DateTime, Segment) %>%
  summarise(VMT_direction_15min = sum(VMT_2040_15),
            TT_hour_direction_15min = sum(TT_hour),
            direction_length  = max(direction_length),
            FF_direction = max(FF_direction)) %>%
  mutate(FF_TT_hour_direction = direction_length / FF_direction,
         TTI = TT_hour_direction_15min / FF_TT_hour_direction) %>%
  # group_by(Segment) %>%
  group_by(direction) %>%
  summarise(quant = Hmisc::wtd.quantile(TTI,VMT_direction_15min,0.95)) 

return(PTI)

}

delay_per_user <- function(input_d, alternative, group,dp = c('Morning','Afternoon'), wd =c('Saturday','Sunday')){

delay <- alternative %>%
  mutate(doy = yday(DateTime)) %>%
  filter(DayPeriod %in% dp) %>%
  merge(input_d) %>%
  mutate(Flow_2040 = Demand_Hour_2040_all_lanes / demand_flow_factor,
         VMT_2040_15 = Flow_2040 * 0.25 * Length,
         wkday=weekdays(.$DateTime),
         direction = ifelse(Segment < 6,'EB','WB')) %>%
         # cuts = cut(.$pred_final,bins,echo.lowest = TRUE),
         # TTI = extract_last_no(cuts)) %>%
  select(DateTime, Segment, wkday, VMT_2040_15, doy, TTI = pred_final, direction, Length, FF) %>%
  filter(wkday %!in% wd) %>%
  mutate(TT_hour = (TTI * Length) / FF) 

dir_len <- delay %>%
  group_by(Segment, direction) %>%
  summarise(m = mean(Length),
            f = mean(FF)) %>%
  group_by(direction) %>%
  summarise(direction_length = sum(m),
            FF_direction = mean(f))

delay <- delay %>%
  merge(dir_len) %>%
  group_by(DateTime, direction) %>%
  # group_by(DateTime, Segment) %>%
  summarise(VMT_direction_15min = sum(VMT_2040_15),
            TT_hour_direction_15min = sum(TT_hour),
            direction_length  = max(direction_length),
            FF_direction = max(FF_direction)) %>%
  mutate(FF_TT_hour_direction = direction_length / FF_direction,
         TTI = TT_hour_direction_15min / FF_TT_hour_direction, 
         delay_vehicle = ifelse((TT_hour_direction_15min > FF_TT_hour_direction),
                                (TT_hour_direction_15min - FF_TT_hour_direction) * (VMT_direction_15min/direction_length),0)
         ) 

return(delay)

}

allday <- c('Morning','Lunch','Afternoon','Evening','Night')
allweek <- c('Saturday','Sunday','Monday','Tuesday','Wednesday','Thursday','Friday')
wkday <- c('Monday','Tuesday','Wednesday','Thursday','Friday')
peak <-  c('Morning','Afternoon')

PMT_PHT <- function(input_d, alternative,dp = allday,
                    grp = 'direction',occupancy,wd = allweek,occ_dat) {

#
# input_d <-  vehicle_GP
# alternative <- GP_2040
# occupancy <- occ_mnapss_gp
# input_d <-  vehicle_MNPass_ff_offpeak
# alternative <- pmt_pht_mnpass_ff_offpeak
# occupancy <- occ_GP
# group <- 'direction'
# dp = c('Morning','Afternoon')
# dp = c('Lunch','Evening','Night')
# dp = allday
# wd=allweek
# occ_dat <- occ %>%
#   filter(Alternative == 'GP') %>%
#   select(occupancy,DayPeriod)

results = list()  
  
throughput = alternative %>%
  mutate(doy = yday(DateTime)) %>%
  merge(input_d) %>%
  mutate(Flow_2040 = Demand_Hour_2040_all_lanes / demand_flow_factor,
         VMT_2040_15 = Flow_2040 * 0.25 * Length,
         wkday=weekdays(.$DateTime),
         direction = ifelse(Segment < 6,'EB','WB')) %>%
  filter(DayPeriod %in% dp,
         wkday %in% wd) %>%
  select(DateTime, Segment, wkday, VMT_2040_15, doy, TTI = pred_final, direction, Length, FF,DayPeriod) %>%
  mutate(TT_hour = (TTI * Length) / FF) %>%
  merge(occ_dat)

results['PHT'] =  throughput %>%
  summarise(PHT = sum((TT_hour * VMT_2040_15 * occupancy) / Length,na.rm = TRUE))

results['PMT'] = throughput %>%
  summarise(PMT = sum((VMT_2040_15 * occupancy) / Length,na.rm = TRUE))

return(results)

}


```

```{r}
occ <- read.csv("H:/Projects/11000/11155/TraffStudy/Reliability/Reliability_processing/Future/reliability_occupancy.csv")
colnames(occ) <- c('Alternative','occupancy','DayPeriod')
occ[occ$Alternative == 'MnPASS Alternative - MnPASS Lane','occupancy'] = occ[occ$Alternative == 'MnPASS Alternative - MnPASS Lane','occupancy']
occ
```

```{r no change}

occ_no_change <- as.numeric(occ[(occ$Alternative == 'no_change')&(occ$DayPeriod == 'Morning'),'occupancy'])

vehicle_no_change <-  vehicle_tru(no_change_2040)
thru_no_change <- agg_vehicle_thru(demand_flow_factor, no_change_2040,agg)
thru_no_change$occupancy <- thru_no_change$Vol * occ_no_change
thru_no_change$Alternative <- 'no_change'


PTI_no_change <- agg_PTI(demand_flow_factor, no_change_2040,agg)
PTI_no_change$Alternative <- 'no_change'

delay_no_change <- delay_per_user(demand_flow_factor, no_change_2040,agg)
delay_no_change$occ <- occ_no_change
delay_no_change <- delay_no_change %>%
  group_by(direction) %>%
  mutate(delay_user = delay_vehicle * occ) %>%
  summarise(total_delay = sum(delay_user,na.rm = TRUE),
            VMT = sum(VMT_direction_15min,na.rm = TRUE),
            Length = mean(direction_length),
            occ = mean(occ)) %>%
  mutate(Vol = VMT/Length,
         thru = (VMT/Length)*occ,
         delay = total_delay/thru)
delay_no_change$Alternative <- 'no_change'

occ_d <- occ %>%
  filter(Alternative == 'no_change') %>%
  select(occupancy,DayPeriod)

vehicle_no_change <-  vehicle_tru(no_change_2040, dp=allday)
pmt_pht_no_change <- PMT_PHT(vehicle_no_change,no_change_2040,occupancy = occ_no_change, occ_dat = occ_d)
pmt_pht_no_change['alternative'] = 'no_change'
```

```{r GP}

occ_GP <- as.numeric(occ[(occ$Alternative == 'GP')&(occ$DayPeriod == 'Morning'),'occupancy'])

vehicle_GP <-  vehicle_tru(GP_2040)
thru_GP <-  agg_vehicle_thru(demand_flow_factor, GP_2040, agg)
thru_GP$occupancy <- thru_GP$Vol * occ_GP
thru_GP$Alternative <- 'GP'

PTI_GP <- agg_PTI(demand_flow_factor, GP_2040,agg)
PTI_GP$Alternative <- 'GP'

delay_GP <- delay_per_user(demand_flow_factor, GP_2040,agg)
delay_GP$occ <- occ_GP
delay_GP <- delay_GP %>%
  group_by(direction) %>%
  mutate(delay_user = delay_vehicle * occ) %>%
  summarise(total_delay = sum(delay_user,na.rm = TRUE),
            VMT = sum(VMT_direction_15min,na.rm = TRUE),
            Length = mean(direction_length),
            occ = mean(occ)) %>%
  mutate(Vol = VMT/Length,
         thru = (VMT/Length)*occ,
         delay = total_delay/thru)
delay_GP$Alternative <- 'GP'

occ_d <- occ %>%
  filter(Alternative == 'GP') %>%
  select(occupancy,DayPeriod)

vehicle_GP <-  vehicle_tru(GP_2040,dp=allday)
pmt_pht_GP <- PMT_PHT(vehicle_GP,GP_2040,occupancy = occ_GP,occ_dat = occ_d)
pmt_pht_GP['alternative'] = 'GP'
```

```{r mnpass ff}

occ_mnpass_ff <- as.numeric(occ[(occ$Alternative == 'MnPass_ff')&(occ$DayPeriod == 'Morning'),'occupancy'])

vehicle_MNPass_ff <- vehicle_tru_mnPass_ff(MNPass_2040_FF)
thru_MNPass_ff <- select(MNPass_2040_FF, -Demand_Hour_2040_all_lanes) %>%
  mutate(Demand_Hour_2040_all_lanes = MNPass_demand_hour_final) %>%
  agg_vehicle_thru(alternative = .,demand_flow_factor, agg)
thru_MNPass_ff$occupancy <- thru_MNPass_ff$Vol * occ_mnpass_ff
thru_MNPass_ff$Alternative <- 'MNPass'

PTI_MNPass_ff <- agg_PTI(demand_flow_factor,
                         select(MNPass_2040_FF, -Demand_Hour_2040_all_lanes) %>%
                           mutate(Demand_Hour_2040_all_lanes = MNPass_demand_hour_final),
                         agg)
PTI_MNPass_ff$Alternative <- 'MnPass'

delay_MnPass_ff <- delay_per_user(demand_flow_factor, 
                                  select(MNPass_2040_FF, -Demand_Hour_2040_all_lanes) %>%
                           mutate(Demand_Hour_2040_all_lanes = MNPass_demand_hour_final),
                         agg)

delay_MnPass_ff$occ <- occ_mnpass_ff
delay_MnPass_ff <- delay_MnPass_ff %>%
  group_by(direction) %>%
  mutate(delay_user = delay_vehicle * occ) %>%
  summarise(total_delay = sum(delay_user,na.rm = TRUE),
            VMT = sum(VMT_direction_15min,na.rm = TRUE),
            Length = mean(direction_length),
            occ = mean(occ)) %>%
  mutate(Vol = VMT/Length,
         thru = (VMT/Length)*occ,
         delay = total_delay/thru)
delay_MnPass_ff$Alternative <- 'MNPass_ff'

occ_d <- occ %>%
  filter(Alternative == 'MnPass_ff') %>%
  select(occupancy,DayPeriod)

vehicle_MNPass_ff <-  vehicle_tru_mnPass_ff(MNPass_2040_FF,dp = allday)
pmt_pht_mnpass_ff <- select(MNPass_2040_FF, -Demand_Hour_2040_all_lanes) %>%
  mutate(Demand_Hour_2040_all_lanes = MNPass_demand_hour_final) %>%
  PMT_PHT(vehicle_MNPass_ff,alternative = .,occupancy = occ_mnpass_ff,occ_dat= occ_d)
pmt_pht_mnpass_ff['alternative']= 'MnPass_ff'



```

```{r mnpassGP}

occ_mnpass_gp = as.numeric(occ[(occ$Alternative == 'MnPass_GP')&(occ$DayPeriod == 'Morning'),'occupancy'])

##
vehicle_MNPass_remain <- vehicle_tru_mnPass_remain(MNPass_2040_remaining_lanes)
vehicle_MNPass_remain <- merge(vehicle_MNPass_remain, 
                               select(vehicle_MNPass_ff, Segment, DayPeriod, doy, Flow_Hour_2040_mnpass_lane_day_dp_sum)) %>%
  mutate(Flow_Hour_2040_remain_lanes_day_dp_sum = 
           Flow_Hour_2040_remain_lanes_day_dp_sum - Flow_Hour_2040_mnpass_lane_day_dp_sum,
         demand_flow_factor = Demand_Hour_2040_all_lanes_day_dp_sum /Flow_Hour_2040_remain_lanes_day_dp_sum)


thru_MNPass_remain <- select(MNPass_2040_remaining_lanes, -Demand_Hour_2040_all_lanes) %>%
  mutate(Demand_Hour_2040_all_lanes = Remaining_all_lanes_demand_hour) %>%
  agg_vehicle_thru(alternative = .,demand_flow_factor, agg)  
thru_MNPass_remain$occupancy <- thru_MNPass_remain$Vol * occ_mnpass_gp
  
thru_MNPass_remain$Alternative <- 'MNPass'

##
PTI_MNPass_GP <- agg_PTI(demand_flow_factor, 
                         select(MNPass_2040_remaining_lanes, -Demand_Hour_2040_all_lanes) %>%
                           mutate(Demand_Hour_2040_all_lanes = Remaining_all_lanes_demand_hour),agg)
PTI_MNPass_GP$Alternative <- 'MnPass_GP'

##
delay_MnPass_GP <- delay_per_user(demand_flow_factor, 
                         select(MNPass_2040_remaining_lanes, -Demand_Hour_2040_all_lanes) %>%
                           mutate(Demand_Hour_2040_all_lanes = Remaining_all_lanes_demand_hour),agg)

delay_MnPass_GP$occ <-occ_mnpass_gp
delay_MnPass_GP <- delay_MnPass_GP %>%
  group_by(direction) %>%
  mutate(delay_user = delay_vehicle * occ) %>%
  summarise(total_delay = sum(delay_user,na.rm = TRUE),
            VMT = sum(VMT_direction_15min,na.rm = TRUE),
            Length = mean(direction_length),
            occ = mean(occ)) %>%
  mutate(Vol = VMT/Length,
         thru = (VMT/Length)*occ,
         delay = total_delay/thru)
delay_MnPass_GP$Alternative <- 'MNPass_GP' 

occ_d <- occ %>%
  filter(Alternative == 'MnPass_GP') %>%
  select(occupancy,DayPeriod)


vehicle_MNPass_remain <-  vehicle_tru_mnPass_remain(MNPass_2040_remaining_lanes,
                                                dp = allday)
pmt_pht_mnpass_remain <- select(MNPass_2040_remaining_lanes, -Demand_Hour_2040_all_lanes) %>%
  mutate(Demand_Hour_2040_all_lanes = Remaining_all_lanes_demand_hour) %>%
  PMT_PHT(vehicle_MNPass_remain,alternative = .,occupancy = occ_mnpass_gp,occ_dat=occ_d)
pmt_pht_mnpass_remain['alternative'] = 'MnPass_GP'




```

```{r, fig.width=10}
flow_mnpass_ff <- vehicle_tru_mnPass_ff(MNPass_2040_FF, grpby = 'Hour') %>%
  select(Segment,Hour,doy,Flow_Hour_2040_mnpass_lane_day_dp_sum) %>%
  mutate(mnpass_ff_flow = Flow_Hour_2040_mnpass_lane_day_dp_sum/4)

flow_mnpass_GP <- vehicle_tru_mnPass_remain(MNPass_2040_remaining_lanes,grpby = 'Hour') %>%
  merge(Segments_494[,c('Segment','Lanes')]) %>%
  select(Segment,Hour,doy,Flow_Hour_2040_remain_lanes_day_dp_sum,Lanes) %>%
  mutate(mnpass_GP_flow = (Flow_Hour_2040_remain_lanes_day_dp_sum/Lanes)/4)

mnpass_flow_comp <- merge(flow_mnpass_ff,flow_mnpass_GP) %>%
  mutate(diff = mnpass_GP_flow - mnpass_ff_flow,DayPeriod = ifelse(Hour <10,'Morning','Evening'))

mnpass_flow_comp %>%
  filter(diff == 0) %>%
  melt(id.vars = c('Segment','Hour','doy','DayPeriod'), measure.vars = c('mnpass_ff_flow','mnpass_GP_flow'),
       variable.name = 'alternative',value.name = 'flow') %>%
  group_by(doy,DayPeriod,alternative)%>%
  summarise(flow = max(flow),)%>%
  ggplot(aes(x=doy,y=flow,color=alternative)) +
  # ggplot(aes(x=doy,y=diff)) +
  geom_line()+
  # geom_smooth()+
  facet_wrap(.~DayPeriod, nrow = 2, scales = 'free')
```


```{r mnpass combined}
###MNPASS combined
delay_MnPass_ff_comb <- delay_per_user(vehicle_MNPass_ff, 
                                  select(MNPass_2040_FF, -Demand_Hour_2040_all_lanes) %>%
                           mutate(Demand_Hour_2040_all_lanes = MNPass_demand_hour_final),
                         agg)
delay_MnPass_GP_comb <- delay_per_user(vehicle_MNPass_remain, 
                         select(MNPass_2040_remaining_lanes, -Demand_Hour_2040_all_lanes) %>%
                           mutate(Demand_Hour_2040_all_lanes = Remaining_all_lanes_demand_hour),agg)
delay_MnPass_ff_comb$occ <- as.numeric(occ[(occ$Alternative == 'MnPass_ff')&(occ$DayPeriod == 'Morning'),'occupancy'])
delay_MnPass_GP_comb$occ <- as.numeric(occ[(occ$Alternative == 'MnPass_GP')&(occ$DayPeriod == 'Morning'),'occupancy'])

delay_MnPass <- rbind(delay_MnPass_ff_comb, delay_MnPass_GP_comb) %>%
  group_by(direction) %>%
  mutate(delay_user = delay_vehicle * occ) %>%
  summarise(total_delay = sum(delay_user,na.rm = TRUE),
            VMT = sum(VMT_direction_15min,na.rm = TRUE),
            Length = mean(direction_length),
            occ = mean(occ)) %>%
  mutate(Vol = VMT/Length,
         thru = (VMT/Length)*occ,
         delay = total_delay/thru)
delay_MnPass$Alternative <- 'MNPass'
```

```{r}
final_delay <- rbind(delay_GP, delay_MnPass, delay_MnPass_ff, delay_MnPass_GP, delay_no_change)

```


```{r}
PTI <- rbind(PTI_GP,PTI_MNPass_ff, PTI_MNPass_GP, PTI_no_change)

```

```{r}
pmt_pht_494 <- rbind(pmt_pht_GP, pmt_pht_mnpass_ff, pmt_pht_mnpass_remain, 
                     pmt_pht_no_change)

```



```{r, fig.width=10}

final_thru <- rbind(thru_GP, thru_no_change,thru_MNPass_remain, thru_MNPass_ff)
myColors <- colors()[c(24,30,507,552,59,53,652,256,258)]
names(myColors) <- levels(final_thru$TTI_Cat)
colScale <- scale_colour_manual(name = "TTI_Cat",values = myColors)
fillScale <- scale_fill_manual(name = "TTI_Cat",values = myColors)

final_thru <- final_thru[!is.na(final_thru$TTI_Cat),]

ggplot(final_thru, aes(x=Alternative, y=occupancy, fill=TTI_Cat)) +
# ggplot(final_thru, aes(x=Alternative, y=demand_flow_factoroccupancy, fill=TTI_Cat)) +
  geom_col()+
  facet_wrap(.~direction)+
  # facet_wrap(.~Segment)+
  scale_y_continuous(name="Person Throughput",
  # scale_y_continuous(name="Vehicle Throughput",
                     # labels = scales::comma)+
                     breaks = seq(0,250000,1000))+
  # colScale + fillScale +ggtitle('Person Throughput - 7:30-8:30 17:15-18:15 - Average Weekday')
  # colScale + fillScale +ggtitle('Vehicle Throughput - 7:30-8:30 17:15-18:15 - Average Weekday Model Occupancy')
  colScale + fillScale +ggtitle('Person Throughput - 6:00-9:00 15:30-18:30 - Average Weekday')
  # colScale + fillScale +ggtitle('Vehicle Throughput - 6:00-9:00 15:30-18:30  - Average Weekday Model Occupancy')
    # colScale + fillScale +ggtitle('Person Throughput - 5:00-10:00 14:00-19:00 - Average Weekday')
  # colScale + fillScale +ggtitle('Vehicle Throughput - 5:00-10:00 14:00-19:00 - Average Weekday Model Occupancy')

```

```{r}
# write.csv(final_thru,'Final tables/final_thru.csv')
```


```{r final numbers}
person_trips <- final_thru %>%
  group_by(Alternative, direction) %>%
  summarise(person_trips = sum(occupancy))

ff_person_trips <-  final_thru %>%
  filter(TTI_Cat %in% c('<1.0 TTI','1.0 TTI - 1.25 TTI')) %>%
  group_by(Alternative, direction) %>%
  summarise(person_trips = sum(occupancy))

```

```{r}
# write.csv(PTI, 'Final tables/PTI_5_10_2_7.csv')
# write.csv(person_trips, 'Final tables/person_trips_5_10_2_7.csv')
# write.csv(ff_person_trips, 'Final tables/ff_person_trips_5_10_2_7.csv')
# write.csv(final_delay,'Final tables/final_delay_5_10_2_7.csv')

# write.csv(PTI, 'Final tables/PTI_6_9_330_630.csv')
# write.csv(person_trips, 'Final tables/person_trips_6_9_330_630.csv')
# write.csv(ff_person_trips, 'Final tables/ff_person_trips_6_9_330_630.csv')
# write.csv(final_delay,'Final tables/final_delay_6_9_330_630.csv')

# write.csv(PTI, 'Final tables/PTI_730_830_1715_1815.csv')
# write.csv(person_trips, 'Final tables/person_trips_730_830_1715_1815.csv')
# write.csv(ff_person_trips, 'Final tables/ff_person_trips_730_830_1715_1815.csv')
# write.csv(final_delay,'Final tables/final_delay_730_830_1715_1815.csv')

# write.csv(pmt_pht_494, 'Final tables/pmt_pht/pmt_pht_494_2040_allday.csv')

# write.csv(PTI, 'Final tables/PTI_5_10_2_7_2020.csv')
# write.csv(person_trips, 'Final tables/person_trips_5_10_2_75_2020.csv')
# write.csv(ff_person_trips, 'Final tables/ff_person_trips_5_10_2_7_2020.csv')
# write.csv(final_delay,'Final tables/final_delay_5_10_2_7_2020.csv')

# write.csv(pmt_pht_494, 'Final tables/pmt_pht_494_2020.csv')
```


