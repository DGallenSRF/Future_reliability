---
title: "I 94 Reliability"
output:
  html_document:
    df_print: paged
---

```{r setup,message=FALSE, include=FALSE}
knitr::opts_knit$set(root.dir = 'C:/Users/dgallen/Desktop/R/Reliability')

##below are a list of packages required to run the markdown file
library(tidyverse)
library(lubridate)
library(gridExtra)
library(reshape2)
library(zoo)
library(rgdal)
library(mgcv)
library(data.table)
library(plotly)
library(broom)
library(nlstools)
library(purrr)

```




## Segment 4 N 

Read data from directory 'C:/Users/dgallen/Desktop/R/Reliability'

```{r read data, include = FALSE}
# dat <- read.csv('N_1_final_rev2.csv',stringsAsFactors = FALSE)
# dat <- read.csv('N_2_final_rev3.csv',stringsAsFactors = FALSE)
# dat <- read.csv('S_3_final_rev3.csv',stringsAsFactors = FALSE)
# dat <- read.csv('S_4_final_rev2.csv',stringsAsFactors = FALSE)
# dat <- read.csv('3_N.csv',stringsAsFactors = FALSE)
# dat <- read.csv('4_N.csv',stringsAsFactors = FALSE)
# dat <- read.csv('1_S.csv',stringsAsFactors = FALSE)
dat <- read.csv('2_S.csv',stringsAsFactors = FALSE)
```


```{r fix column names, include = FALSE}

colnames(dat) <-trimws(colnames(dat))
colnames(dat)[1] <- "TimeStamp"

```


```{r set fixed values, include=FALSE}

# 1N
# Dist1 <- 2.18
# Exist1 <- 129000
# Future <- 1.078
# Lanes <- 4


#2N
# Dist1 <- 2.88
# Exist1 <- 121310
# Future <- 1.077
# Lanes <- 5

#3S
# Dist1 <- 2.88
# Exist1 <- 121793
# Future <- 1.079
# Lanes <- 3

# 4S
# Dist1 <- 2.18
# Exist1 <- 12900
# Future <- 1.078
# Lanes <- 4


### NORTH OF 694

# 3N
# Dist1 <- 1.95
# Exist1 <- 62579
# Future <- 1.161
# Lanes <- 3

# 4N
# Dist1 <- 1.6
# Exist1 <- 56000
# Future <- 1.143
# Lanes <- 2.5

# 1S
# Dist1 <- 1.6
# Exist1 <- 56000
# Future <- 1.155
# Lanes <- 2

# 2S
Dist1 <- 1.95
Exist1 <- 60645
Future <- 1.153
Lanes <- 3

head(dat)
```

### Set fixed values. 

Distance of segment is `r Dist1`
Existing Demand is `r Exist1`
Lanes in segment: `r Lanes`



### Add variables to the existing dataset. 

15 minute volume takes the VMT for each time bin and divides by the length of the segment. Unit: Vehicles per mile.
Speed is the segment length divided by the travel time ( * 60). Unit: Miles per hour.
Hourly_Flow is the 15 minute volume multipled by 4 and divided by the number of lanes. Unit: Vehicles per hour.
Density is the Hourly Flow divided by speed. Unit: Vehicles per hour.

We also create a variable that measures the delay type experienced by the segment. Weather (snow) events and crashes were tracked for the time period. If the segment experiences a weather event and a crash, weather will be the controlling delay type.

```{r add_variables}

Rel_2014 <- dat %>% mutate(Vol_15_min  = VMT_total/Dist1,
                           Speed       = Dist1/TT_mean*60,
                           Hourly_Flow = Vol_15_min*4/Lanes,
                           Dens        = Hourly_Flow/Speed,
                           # DateTime    = as.POSIXct(TimeStamp,format="%m/%d/%Y %H:%M"),
                           DateTime    = as.POSIXct(TimeStamp,format="%Y%m%d %H:%M"),
                           # Hour        = as.factor(format(DateTime,format = '%H')),
                           # Month       = as.factor(format(DateTime,format = '%m')),
                           WeekDay     = as.factor(weekdays(DateTime)),
                           DateTimeSec = as.numeric(DateTime),
                           Delay_type  = (ifelse(Weather == 1, 
                                                'Weather',
                                                ifelse(Crash == 1, 
                                                       'Crash',
                                                       'None'))),
                           is_Delay       = ifelse(Delay_type == 'None', 'No_Delay', 'Delay'),
                           Index = seq(1,length(Speed),1)) %>%
  filter(!is.na(DateTime))
```

```{r}

# library(randomForest)
# rf <- randomForest(TT_mean ~ WeekDay + Hour + Month + Dens + VMT_total, data = Rel_2014, ntree = 1000)

```



```{r filter for outlier}

Rel_2014 <- Rel_2014 %>%
  mutate(Rollavg = (rollmean(TT_mean,k=8,fill = TT_mean, align = 'right') +
                      rollmean(TT_mean,k=8,fill = TT_mean, align = 'left'))/2) %>%
  mutate(outlier = ifelse(abs(Rollavg - TT_mean) > 6 * sd(Rollavg), TRUE, FALSE)) %>%
  # filter(Dens <= 125) #4N
  # filter(Dens <= 150) #1S
  filter(Dens <= 75) #2S

boxplot(Rel_2014$Dens)
```

``` {r bin data}

# 1N
# bins <- c(seq(floor(min(Rel_2014$Dens)),30,2),
#           40,50,ceiling(max(Rel_2014$Dens)))

# 
bins <- c(seq(floor(min(Rel_2014$Dens)),max(Rel_2014$Dens)+2,2))

#1S
# bins <- c(seq(floor(min(Rel_2014$Dens)),50,2),
#           60,70,80,100,125,150,round(max(Rel_2014$Dens)+1,0))

Rel_2014$cut <- cut(Rel_2014$Dens,bins,include.lowest = TRUE)
Rel_2014$Density_bin <- as.numeric(stringi::stri_match_last_regex(Rel_2014$cut,'[0-9]+')) 

Rel_2014 %>%
  group_by(Density_bin,is_Delay) %>%
  summarise(Count = n()) %>%
  arrange(Density_bin) %>%
  dcast(Density_bin ~ is_Delay)
```


### Percentile Bins

We will break down the dataset into each delay type and then further into percentiles. 

```{r percentiles, include=FALSE}

# p <- c(.05,.1,0.25,0.5,0.75,0.9,.95)

# 3N 4N 1S 2S
p <- c(.15,0.25,0.5,0.75,0.85)
```


The percentiles choosen are `r p`.

For each quantile a travel time quantile is calculated. We also want to calculate a Free Floew Speed for each quantile. 

```{r create binned dataset, include=FALSE}

Rel_2014_bin_dt <- Rel_2014 %>%
  mutate(Density_bin = as.numeric(stringi::stri_match_last_regex(cut,'[0-9]+'))) %>%
  group_by(is_Delay,Density_bin) %>%
  # group_by(Delay_type,Density_bin) %>%
  summarise(quantiles = list(sprintf("%1.0f%%", p*100)),
            TT_quantile = list(quantile(TT_mean,p))) %>%
  unnest() %>%
  mutate(Speed = Dist1/TT_quantile*60,
         Flow = Speed * Density_bin,
         quantiles = as.factor(quantiles)) %>%
  as.data.frame()

Rel_2014_FF <- Rel_2014_bin_dt %>%
  # group_by(Delay_type,quantiles) %>%
  group_by(is_Delay,quantiles) %>%
  summarise(FF_quantile = round(quantile(Flow/Density_bin,.95, na.rm = TRUE),0))


Rel_2014_bin_dt <- merge(Rel_2014_bin_dt,Rel_2014_FF) %>%
  mutate(Index_bin = as.integer((seq(1,length(FF_quantile),1))),
         TTI = TT_quantile/(Dist1/FF_quantile * 60))

head(Rel_2014_bin_dt)
```

The Free Flow speeds were calcuated using the 95th percentile speeds. 

```{r free flow plot, fig.width = 11}
ff <- ggplot()+
  geom_point(data = data.frame(Rel_2014_bin_dt),aes(x=Density_bin,y=Flow, color=quantiles))+
  geom_abline(data = data.frame(Rel_2014_FF), aes(slope = FF_quantile, intercept = 0, linetype = 'dashed', color = quantiles))+
  # facet_grid(~Delay_type)
  facet_grid(~is_Delay)
ggplotly(ff)
```


A look at the Density vs travel time plots. A generic smooting function has been added. 

```{r Density vs TT, fig.width = 11}
tt <- ggplot()+
  geom_point(data=Rel_2014_bin_dt,aes(x= Density_bin,y = TT_quantile, color= quantiles))+
  geom_smooth(data=Rel_2014_bin_dt,aes(x= Density_bin,y = TT_quantile, color= quantiles),span=1,se=F)+
  # facet_grid(~Delay_type)
  facet_grid(~is_Delay)
ggplotly(tt)
```



We need to find the congestion point for each Delay type and percentile.

```{r find congestion points freeway, include=FALSE}

# model_crash <- Rel_2014_bin_dt %>%
#   filter(Delay_type == 'Crash') %>%
#   nest(-Delay_type,-quantiles) %>%
#   # as.tibble() %>%
#   mutate(fit = map(data, ~ loess(Flow ~ Density_bin, span = 0.75, data = .,)),
#          results = map(fit, augment)) %>%
#   as.tibble() %>%
#   unnest(results)
# 
# model <- Rel_2014_bin_dt %>%
#   filter(Delay_type != 'Crash') %>%
#   nest(-Delay_type,-quantiles) %>%
#   # as.tibble() %>%
#   mutate(fit = map(data, ~ loess(Flow ~ Density_bin, span = 1, data = .,)),
#          results = map(fit, augment)) %>%
#   as.tibble() %>%
#   unnest(results) %>%
#   rbind(model_crash)

```

```{r model for signal road}
# model_non_delay <- Rel_2014_bin_dt %>%
#   filter(Delay_type != 'None') %>%
#   nest(-Delay_type,-quantiles) %>%
#   # as.tibble() %>%
#   mutate(fit = map(data, ~ loess(Flow ~ Density_bin, span = 0.75, data = .,)),
#          results = map(fit, augment)) %>% 
#   as.tibble() %>%
#   unnest(results)

model <- Rel_2014_bin_dt %>%
  # filter(Delay_type == 'None') %>%
  nest(-is_Delay,-quantiles) %>%
  # as.tibble() %>%
  mutate(fit = map(data, ~ loess(Flow ~ Density_bin, span = 1, data = .,)),
         results = map(fit, augment)) %>% 
  as.tibble() %>%
  unnest(results)

```

```{r model-max original}

model_max <- model %>%
  group_by(is_Delay,quantiles) %>%
  # group_by(Delay_type,quantiles) %>%
  # summarise(max = max(.fitted))
  filter(.fitted == max(.fitted)) %>%
  select(is_Delay, quantiles, Cong_Flow = .fitted, Cong_Density = Density_bin)
  # select(Delay_type, quantiles, Cong_Flow = .fitted, Cong_Density = Density_bin)
```


```{r 4N edits}
# # #4N EDITS

# model_max <- data.frame(is_Delay = c(rep('Delay',5),rep('No_Delay',5)),
#                         quantiles = rep(c('15%','25%','50%',"75%",'85%'),2),
#                         Cong_Flow = c(1450,1360,1330,1290,1275,
#                                       1435,1430,1410,1370,1350),
#                         Cong_Density = c(34,34,44,44,44,
#                                          36,40,50,58,58))
```

```{r 3N edits}


# model_max <- data.frame(is_Delay = c(rep('Delay',5),rep('No_Delay',5)),
#                         quantiles = rep(c('15%','25%','50%',"75%",'85%'),2),
#                         Cong_Flow = c(1380,1340,1280,1250,1192,
#                                       1360,1355,1310,1200,1230),
#                         Cong_Density = c(52,42,44,50,42,
#                                          34,40,38,40,50))
```

```{r 2s edits}

model_max <- data.frame(is_Delay = c(rep('Delay',5),rep('No_Delay',5)),
                        quantiles = rep(c('15%','25%','50%',"75%",'85%'),2),
                        Cong_Flow = c(1460,1460,1460,1330,1305,
                                      1479,1450,1360,1130,780),
                        Cong_Density = c(32,32,32,40,40,
                                         32,34,34,32,30))
```

```{r 1S edits}
#1S EDITS


# model_max <- data.frame(is_Delay = c(rep('Delay',5),rep('No_Delay',5)),
#                         quantiles = rep(c('15%','25%','50%',"75%",'85%'),2),
#                         Cong_Flow = c(2300,2200,2100,1990,1940,
#                                       2270,2230,2113,2070,2020),
#                         Cong_Density = c(76,62,62,62,62,
#                                          68,72,72,90,90))
```

### Plots

Below are the Flow vs Density plots for each condition. 

Verical lines show the congestion Density for each condition. 

```{r plots weather delay,  fig.width = 10, fig.height=5}

f <- ggplot()+
  geom_point(data=filter(Rel_2014_bin_dt,Delay_type == 'Weather') ,
             aes(x= Density_bin,y = Flow, color= quantiles))+
  geom_smooth(data=filter(Rel_2014_bin_dt,Delay_type == 'Weather'),
              aes(x= Density_bin,y = Flow, color= quantiles),span =1,se=F)+
  geom_vline(data=filter(model_max,Delay_type == 'Weather'),aes(xintercept=Cong_Density, color = quantiles)) +
  ggtitle('Delay Type = "Weather"')
ggplotly(f)

```

```{r plots crash delay,  fig.width = 10, fig.height=5}



f <- ggplot()+
  geom_point(data=filter(Rel_2014_bin_dt,Delay_type == 'Crash') ,
             aes(x= Density_bin,y = Flow, color= quantiles))+
  geom_smooth(data=filter(Rel_2014_bin_dt,Delay_type == 'Crash'),
              aes(x= Density_bin,y = Flow, color= quantiles),span =0.75,se=F)+
  geom_vline(data=filter(model_max,Delay_type == 'Crash'),aes(xintercept=Cong_Density, color = quantiles)) +
  ggtitle('Delay Type = "Crash"')
ggplotly(f)

```

```{r plots no delay, fig.width = 10, fig.height=5}

dat <- filter(Rel_2014_bin_dt,
              is_Delay == 'No_Delay')

f <- ggplot()+
  geom_point(data=dat,
             aes(x= Density_bin,y = Flow, color= quantiles))+
  geom_smooth(data=dat,
              aes(x= Density_bin,y = Flow, color = quantiles),span =1,se=F)+
  geom_vline(data=filter(model_max,is_Delay == 'No_Delay'),aes(xintercept=Cong_Density, color = quantiles)) +
  # geom_vline(data=filter(model_max,Delay_type != 'None'),aes(xintercept=Cong_Density, color = quantiles)) +
  ggtitle('Delay Type = "None"')
ggplotly(f)
```


### Demand

We now calcualte Demand.

If Density is less than the congestion density, Demand = Flow.
If density is greated that the congestion density, Demand = 2 x Congestion Flow - Flow. 

TTI is the travel time divided by the travel time at Free Flow. 




```{r calculate demand}
Rel_2014_bin_dt <- merge(Rel_2014_bin_dt,model_max,by = c('is_Delay','quantiles')) %>%
# Rel_2014_bin_dt <- merge(Rel_2014_bin_dt,model_max,by = c('Delay_type','quantiles')) %>%
  mutate(Demand = ifelse(Density_bin <= Cong_Density, Flow,
                         ifelse(Density_bin >= Cong_Density & Flow <= Cong_Flow,Cong_Flow + (Cong_Flow - Flow),Flow)),
         DC = Demand/Cong_Flow) 
    #4N 
  # filter(Demand <=2000)

```

```{r demand vs TTI,  fig.width = 10, fig.height=5}

s <- ggplot()+
  # geom_smooth(data=Rel_2014_bin_dt,aes(x= Flow,y = TT_quantile, color= quantiles),se=F,span = 1)+
  geom_point(data=Rel_2014_bin_dt,aes(x= Demand,y = Density_bin, color= quantiles)) +
  facet_grid(~is_Delay)
ggplotly(s)


```


## Future Model

We now fit a curve to model the demand. 

On the x axis we plot Demand/Congestion Flow and on the Y axis we plot TTI.

The formula we use to model the data is 1 + aplha x D/C ^ beta. A set initial portion of each curve is set to TTI = 1, to correctly model Demand = Flow for now congestion conditions. 

Below is the model output for no delay conditions, 50th percentile:

```{r develop model}
sample_data <- Rel_2014_bin_dt %>%
  filter(is_Delay == 'No_Delay',
         quantiles == '85%') %>%
  select(DC, TTI)


formulaExp <- as.formula(TTI ~(DC <= .65) + (DC > .65) * ( mu * (DC ^ b)))
b <- 3
mu <- 1.5
# preview(formulaExp, data = sample_data, start = list(mu, b))


sample_nls <- nls(formulaExp, data = sample_data, start = list(mu = 1.5, b = 3))
plotfit(sample_nls, smooth = TRUE)

pred <- data.frame(DC = 1.57)
predict(sample_nls,pred)
```


```{r develop breaks for model, include=FALSE}

# 1N
# breaks <- model_max %>% data.frame() %>%
#   mutate(br = c(0.87,0.88,0.87,0.89,0.91,0.91,.845,
#                 0.94,.94,0.95,0.96,0.99,0.99,0.99,
#                 0.99,0.99,0.99,0.98,0.96,0.96,0.95)) %>%
#   select(Delay_type,quantiles,br)

# 2N
# breaks <- model_max %>% data.frame() %>%
#   mutate(br = c(0.86,0.86,0.87,0.865,0.865,0.865,0.865,
#                 0.88,0.895,0.895,0.895,0.95,1.04,1.03,
#                 0.91,0.9,0.91,0.91,.89,0.86,0.79)) %>%
#   select(Delay_type,quantiles,br)

# 3S
# breaks <- model_max %>% data.frame() %>%
#   mutate(br = c(0.92,0.91,0.91,0.92,0.87,0.85,0.92,
#                 0.87,0.9,0.86,0.9,0.9,0.91,0.9,
#                 0.5,0.48,0.5,0.48,0.53,0.49,0.48)) %>%
#   select(Delay_type,quantiles,br)

# 4S
# breaks <- model_max %>% data.frame() %>%
#   mutate(br = c(0.96,0.94,0.955,0.9,0.9,0.98,0.99,
#                 0.9999,0.999,1,0.94,0.89,0.89,0.83,
#                 0.55,0.55,0.58,0.5,0.43,0.6,0.6)) %>%
#   select(Delay_type,quantiles,br)

# 3N
# breaks <- model_max %>% data.frame() %>%
#   mutate(br = c(.65,.65,.6,.4,.4,
#                 .8,.8,.8,.66,.37)) %>%
#   select(is_Delay,quantiles,br)

# 4N
# breaks <- model_max %>% data.frame() %>%
#   mutate(br = c(.85,.74,.6,.33,.23,
#                 .9,.9,.87,.87,.3)) %>%
#   select(is_Delay,quantiles,br)

# 1S
# breaks <- model_max %>% data.frame() %>%
#   mutate(br = c(.7,.65,.48,.4,.25,
#                 .92,.88,.5,.3,.3)) %>%
#   select(is_Delay,quantiles,br)

# 2S
breaks <- model_max %>% data.frame() %>%
  mutate(br = c(.84,.85,.83,.75,.82,
                .92,.85,.75,.56,.65)) %>%
  select(is_Delay,quantiles,br)

Rel_2014_bin_dt <- merge(Rel_2014_bin_dt,breaks)
```

```{r Demand model test, include=FALSE}

func_exp <- function(x) {
  nls(
    TTI ~(DC <= br) + (DC > br) * ( mu * (DC ^ b)),
    start = list(mu = 1.5, b = 3),
    data = x)
}


formulaExp <- as.formula(TTI ~(DC <= br) + (DC > br) * ( mu * (DC ^ b)))

model_nls <- Rel_2014_bin_dt %>%
  # nest(-Delay_type,-quantiles) %>%
  nest(-is_Delay,-quantiles) %>%
  mutate(fit = purrr::map(data, func_exp)) 
  # mutate(pred = purrr::map2(fit,data,predict)) %>%
  # unnest(data,pred)

```

### Predict

We join each model back to the original dataset and create a predicted TTI for each row. 

```{r join roll up, include=FALSE}

Rel_2014_TT_dt <- Rel_2014 %>%
  select(is_Delay,Density_bin,TT_quantile = TT_mean, Index) %>%
  # select(Delay_type,Density_bin,TT_quantile = TT_mean, Index) %>%
  data.table()


Rel_2014_bin_dt <- data.table(Rel_2014_bin_dt) %>% select(-quantiles,quantiles)
setkey(Rel_2014_bin_dt, NULL)
# setkey(Rel_2014_bin_dt,Delay_type,TT_quantile,Density_bin)
setkey(Rel_2014_bin_dt,is_Delay,Density_bin)
Rel_2014_bin_dt <-  Rel_2014_bin_dt[!duplicated(Rel_2014_bin_dt[,1:4]),]

setkey(Rel_2014_bin_dt, NULL)
# setkey(Rel_2014_bin_dt,Delay_type,TT_quantile,Density_bin)
setkey(Rel_2014_bin_dt,is_Delay,Density_bin,TT_quantile)

join_TT <- Rel_2014_bin_dt[Rel_2014_TT_dt, roll = 'nearest', .(TT_q = x.TT_quantile,
                                                 TT_mean = i.TT_quantile,
                                                 Density_bin = Density_bin,
                                                 is_Delay = is_Delay,
                                                 # Delay_type = Delay_type,
                                                 Quantiles = quantiles,
                                                 FF = FF_quantile,
                                                 Cong_Flow = Cong_Flow,
                                                 Cong_Density = Cong_Density,
                                                 Index = Index,
                                                 br = br)]

# join_TT <- Rel_2014_bin_dt[Rel_2014_TT_dt, roll = 'nearest']

join_TT <- join_TT[!duplicated(join_TT$Index),]


Rel_2014_f <- merge(Rel_2014, join_TT[,c('Index','TT_q','Quantiles','Cong_Flow','Cong_Density','FF','br')], by = 'Index', all.x=TRUE)
table(is.na(Rel_2014_f$Cong_Flow))

Rel_2014_f <- Rel_2014_f %>%
  mutate(Demand  = ifelse(Density_bin <= Cong_Density,Hourly_Flow,2*Cong_Flow - Hourly_Flow),
         DC = Demand/Cong_Flow,
         TTI = TT_mean/(Dist1/FF * 60)) %>%
  # nest(-Delay_type, -Quantiles)
  nest(-is_Delay, -Quantiles)

# Rel_2014_f <- merge(Rel_2014_f,model_nls %>% select(Delay_type, Quantiles = quantiles, fit)) %>%
Rel_2014_f <- merge(Rel_2014_f,model_nls %>% select(is_Delay, Quantiles = quantiles, fit)) %>%
  as.tibble() %>%
  mutate(pred = map2(fit,data,predict)) %>%
  as.tibble() %>%
  unnest(data,pred)
```

```{r testing}
x <- data.table(
  # Col1 = c('a','b','c','d','e','f'),
  Col2 = c(1000,30,40)
  # ,
  # Col3 = c(12,10,8,6,4,2)
  )

y <- data.table(
  # Col1 = c('a','b','c','d','e','f','g'),
  Col2 = c(3,13,20,4,6,20,50)
  )

setkey(x,NULL)
setkey(x,Col2)

x[y, roll= Inf]


DT1 <- data.table(x = 10,8,7,6,4)
DT2 <- data.table(y = c(2,4,1,3,5) + 0.01)
setkey(DT1, x)
setkey(DT2, y)
DT1[DT2, roll = 'nearest']

dt <- data.table(aa= c(20,12,55), bb= c(4,2,10), cc= c(5,1,7))
setkey(dt,NULL)
setkey(dt, aa)
ds <- data.table(dd = c(100,50,1,27,40), ee= c('a','b','c','d','e'))
da <- dt[ds,  roll = "nearest", ]


d <- Rel_2014_bin_dt[c(1,74,400,432),]
f <- Rel_2014_TT_dt[1:10,]
setkey(d,is_Delay,Density_bin)
g <- d[f,roll='nearest']


dup <- Rel_2014_bin_dt[1:20,1:4]
setkey(dup,is_Delay,Density_bin,TT_quantile)
dup$dupo <- duplicated(dup)
```



```{r plot pred vs TTI, fig.width = 10, fig.height=5}

pr <- ggplot(Rel_2014_f, aes(x=TTI,y=pred, color=Quantiles))+
  geom_point()+
  scale_x_continuous(breaks = c(1,2,3,4,5))+
  scale_y_continuous(breaks = c(1,2,3,4,5,6))+
  # facet_grid(~Delay_type)
  facet_grid(~is_Delay)
ggplotly(pr)

```


```{r model future demand}
Rel_2014_p <- Rel_2014_f %>%
  mutate(F_Dem = Demand * Future,
         DC    = F_Dem/Cong_Flow) %>%
  # nest(-Delay_type,-Quantiles) %>%
  nest(-is_Delay,-Quantiles) %>%
  # merge(model_nls %>% select(Delay_type, Quantiles = quantiles, fit)) %>%
  merge(model_nls %>% select(is_Delay, Quantiles = quantiles, fit)) %>%
  as.tibble() %>%
  mutate(pred = map2(fit,data,predict)) %>%
  as.tibble() %>%
  unnest(data,pred) %>%
  mutate(TT = pred * (Dist1/FF * 60)) %>%
  select(DateTime, DateTimeSec, TT) 
  # mutate(DateTime = as.character(DateTime))
  
```

```{r dat sequence}
seq_15min_2015 <- data.frame(DateTime=seq(as.POSIXct("2015,01,01",format="%Y,%m,%d"),
                                          as.POSIXct("2016,01,01",format="%Y,%m,%d"),by="15 min"))
seq_15min_2015 <- seq_15min_2015[-1,] %>% data.frame(DateTime = .)

Rel_2014_p <- merge(seq_15min_2015, Rel_2014_p, all.x = TRUE)
Rel_2014_f <- merge(seq_15min_2015, Rel_2014_f, all.x = TRUE)

write.csv(Rel_2014_f,'2_S_exist_pred.csv',row.names = FALSE)
write.csv(Rel_2014_p,'2_S_predict.csv',row.names = FALSE)
getwd()
```

```{r}
 TT_heat <- Rel_2014 %>% 
   select(DateTime, TT_mean, YearDay) %>% 
   mutate(HourMin = format(DateTime, '%H:%M'),
          YearDate = as.POSIXct(format(DateTime, '%Y-%m-%d')),
          TTI = TT_mean/(Dist1/60 * 60),
          TTI_Cat = factor(ifelse(TTI > 4.0,'>4.0 TTI',
                     ifelse(TTI <= 4.0 & TTI > 3.5,'3.5 TTI - 4.0 TTI',
                     ifelse(TTI <= 3.5 & TTI > 3.0,'3.0 TTI - 3.5 TTI',
                     ifelse(TTI <= 3.0 & TTI > 2.5,'2.5 TTI - 3.0 TTI',
                     ifelse(TTI <= 2.5 & TTI > 2.0,'2.0 TTI - 2.5 TTI',
                     ifelse(TTI <= 2.0 & TTI > 1.5,'1.5 TTI - 2.0 TTI',
                     ifelse(TTI <= 1.5 & TTI > 1.25,'45 mph TT - 1.5 TTI',
                     ifelse(TTI <= 1.25 & TTI > 1.0 ,'Speed Limit TT - 45 mph TT',
                     ifelse(TTI <= 1.0 , '<Speed Limit TT', NA))))))))),
                     levels = (c('>4.0 TTI',
                                 '3.5 TTI - 4.0 TTI',
                                 '3.0 TTI - 3.5 TTI',
                                 '2.5 TTI - 3.0 TTI',
                                 '2.0 TTI - 2.5 TTI',
                                 '1.5 TTI - 2.0 TTI',
                                 '45 mph TT - 1.5 TTI',
                                 'Speed Limit TT - 45 mph TT',
                                 '<Speed Limit TT')))) 
 g <- ggplot(TT_heat) +
   geom_tile(aes(x=YearDate,y=HourMin,color = TTI_Cat, fill = TTI_Cat))  +
   theme_tufte(base_size = 15) +
   scale_y_discrete(breaks = break_axis) +
   colScale + fillScale
 g
```






